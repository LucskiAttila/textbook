<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
             Javítsunk valamit a ActivityEditor.java JavaFX programon! https://github.com/nbatfai/future/tree/master/cs/F6 Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467
        </para>
        <para>
             A Future projekt a városok jövőbeli kutatására irányult a város lakóira alapozva, hogy azok innovatív és környezettudatos technológiai megoldásokat használjanak mindennapi feladatai megoldásában és hosszú távú céljai elérésében. Az F6-os projekt arra készült hogy a hallgatók a napi tevékeknységeiket feljegyezzék ugye környezettudatosan. 
             Az F6 projekt java programozési nyelven írt programja az ActivityEditor.java így ezt kellessz fordítanunk és futtatnunk, de ehhez szükségesek a többi fájlok is a projektből, illetve társítani kell a JavaFX-es könyvtárakat is. Mivel ebből elég sokat fog használni a programunk így egy szkriptet készítettem hozzá run néven melynek segítségével fordítom és futtatom is a programot:
        </para>
        <programlisting><![CDATA[
             #!/usr/bin/env bash
             export PATH_TO_FX="/usr/share/openjfx/lib"
             java_modules="javafx.controls,javafx.graphics,javafx.media,javafx.swing,javafx.web"
             rm -f *.class
             /usr/lib/jvm/java-11-openjdk-amd64/bin/javac\
                 --module-path $PATH_TO_FX\
                 --add-modules=$java_modules ActivityEditor.java
             /usr/lib/jvm/java-11-openjdk-amd64/bin/java\
                 --module-path $PATH_TO_FX\
                 --add-modules=$java_modules ActivityEditor
             rm -f *.class
        ]]></programlisting>
        <para>
             Az F6 projektet pedig az alábbi módon tölthetjük le, és indíthatjuk el miután megírtuk a run szkriptet:
        </para> 
        <programlisting><![CDATA[
             git clone https://github.com/nbatfai/future.git
             cd future/cs/F6
             gedit run
             ./run
        ]]></programlisting>
        <para>     
             A feladat az volt hogy javítsunk valamit a kódon, így kibővítettem egy törlés funkcióval amivel törölhetjük a mappáit vagy fájlait a megjelenített könyvtárszerkezetnek a gyökér mappa kivételével, mivel azt az ActivityEditor programunkban hozzuk létre a fa gyökereként nem fájlból olvassuk be. Ahogy az Én magam elemet is létrehozzuk faelemként nem beolvasással hozzuk létre, így ez a két elem fog látszani ha elindeítjuk a programot a City, gaming.props, initF6actFS.sh, me.props, programming.props fájlok használata nélkül. A program könyvtárszerkezete működik a  gaming.props, initF6actFS.sh, me.props, programming.props fájlok használata nélkül is. 
        </para>
        <programlisting language="Java"><![CDATA[
             javafx.scene.control.MenuItem deleteMenuItem = new javafx.scene.control.MenuItem("Törlés");
             addMenu.getItems().add(deleteMenuItem);
	     deleteMenuItem.setOnAction((javafx.event.ActionEvent evt) -> {
             javafx.scene.control.TreeItem item = getTreeItem();
             if (item.getParent() == null ){
             System.out.print("Cannot remove the root node.\n");}
             else{
             java.io.File file = getTreeItem().getValue();
             item.getParent().getChildren().remove(item);
	     deleteDirectory(file);}});}
             public boolean deleteDirectory(java.io.File directory) {
             if(directory.exists()){
             java.io.File[] files = directory.listFiles();
             if(null!=files){
             for(int i=0; i<files.length; i++) {
             if(files[i].isDirectory()) {
             deleteDirectory(files[i]);}
             else {
             files[i].delete();}}}}
             return(directory.delete());} 
        ]]></programlisting>
	<para>
	     Létrehoztunk Törlés menüpontot deleteMenuitem néven majd hozzáadtuk a Menu objektumhoz, majd beállítottunk hozzá egy akciót, mely egy megfelelő esemény bekövetkezésekor hívódik meg. A getTreeitem függvénnyel lekérjük a kijelölt mappát, majd ellenőrizzük almappa e, ha nem akkor hibaüzenetet írunk hogy gyökékönyvtárat nem lehet törölni, ha almappa akkor a remove függvénnyel töröljük az adatszerkezetből, majd töröljük a gépről is, ehhez viszont fájlként kell kezelnünk, majd meghívjuk rá az általunk készített deleteDirectory függvényt. Ez azért szüskséges mivel törölni szeretnénk a kijelölt mappánkat almappáival fájlaival együtt, azaz tartalmával együtt és a delete csak üres mappákkra vagy fájlokra hívható meg. A deleteDirectory függvény úgy működik hogy először ellenőrizzük a paraméterül kapott fájlról hogy létezik e, ha nem akkor a return részhez ugrunk ami meghívja a delete függvényt a nem létező fájlra és hibaüzenetet kapunk a delete függvénytől. Ha viszont létezik a fájl akkor az alfájlait belértve az almappákat is belerakjuk egy tömbbe, majd meghívjuk egyessével a tömb elemeit és ha mappa akkor meghívjuk rá rekurzívan a függvényünket egyébként töröljük a fájlt, majd a mappákat a rekurzív függvényhívások kiértékelődésekor törlil a függvények.                              	
	</para> 
             mediaobject>
             <imageobject>
                 <imagedata fileref="future.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>	 

    <section>
        <title>OOCWC Boost ASIO hálózatkezelése</title>
        <para>
             Mutassunk rá a scanf szerepére és használatára! https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll
        </para>
        <para>
	     A sscanf függvény annyiban tér el a scanf változatától hogy ez az általunk meghatározott forrásból olvassa ki a szöveget, a scanf pedig a szabványos bemenetről. Mindkét függvény visszatérési értéke egy egész szám a parméterül adott referenciáknak a száma amikebe a szövegből beolvastunk értékeket, hiba esetén EOF karakterrel tér vissza, ami olyan karakter ami a char értékkészletén kívül esik. Mindkét függvény használatához az #include <stdio.h> header használata szükséges, illetve az std:: névtér. A sscanf függvény első paramétere az hogy honnan próbálja meg ráilleszteni a második paraméterként megadott mintára a szöveget. A formátumot " " jelek között kell megadni, ahol akármilyen karaktereket megadhatunk akár whitespace-eket például szökózt is, illetve használhatunk karaktertípusokat is ekkor meg kell adni ugye a hozzátartozó változó referenciákat ahova mentse a beolvasott típus értékét illeszkedés esetén, ezeket a függvény további paramétereként adjuk meg. A karaktertípusoknak speciális jelölésük van például a char-nak c, string-nek s, decimal int d, f float point, ahol ugye a char az egy karaktert, a string szöveget, decimal int decimális azaz tízesszámrendszerbeli egész számot, a float point egy tizedes vesszőt tartalmazó nem valós számot. Sztring esetén egy white spac-ig olvas be karaktereket, ehhez char*, a char-hoz is, a float point-hoz float*, az int-hez int* referencia szükséges hogy tároljuk.   
	</para>
        <programlisting language="Java"><![CDATA[
	while ( std::sscanf ( data+nn, "<OK %d %u %u %u>%n", &idd, &f, &t, &s, &n ) == 4 ){
	nn += n;
	gangsters.push_back ( Gangster {idd, f, t, s} );}	
        ]]></programlisting>
        <para>
	     Ebben a példában a sccanf függvényt arra használjuk hogy a data sztring <OK %d %u %u %u> alakú szövegrészeiből Gangster objektumokat hozzunk létre melyeket a gangsters vektorba tárolva különítünk el egymástól, mivel a vektor elemeit lekérdezhetjük majd. Ehhez ugye override-oltuk azaz túlterheltük a scanf függvényt, az nn változót valószínüleg 0 kezdőértékkel definiáltuk egész típussal, melynek értékét az n egész változó értékével növeljük minden beolvasott Gangster objektum után. Az n változó értékét minden beolvasás után a beolvasott sztring karakterjeinek számára módosítja a függvény, beleszámolja a nem illeszkedüket is, ezt a %n speciális karakter adja meg. Fontos hogy ez nem ugyanaz mint a függvény visszatérési értéke mert az fix szám és azoknak a paraméterül adott referenciáknak a száma amikbe beolvasunk a bemenetből. A visszatérési értéke jelen esetben 4, ha jól működik a függvényünk, azaz betud olvasni egy Gangster objektum létrehozásához elegendő változókat, azaz a konstruktorának változóit. A while ciklus addig fogja újból meghívni a scanf függvényt ameddig tud beolvasni újabb gangsters vektor elemet azaz Gangster objektumot. Ahhoz hogy ne olvassuk be kétszer ugyanazt a Gangster objektumot ahhoz növeljük a beolvasási pointer értékét a már beolvasott sztringek hosszával. A %u az unsigned decimal int-eket jelenti azaz aláírás nélküli decimélis egész számokat. Ennek a decimális szava a számjegyeire utal ami tizes számrendszerbeli az 0,1,2,3,4,5,6,7,8,9 számjegyekből épül fel. Az aláírás nélküli rész pedig arra hogy nem tartalmaz negatív egészeket, ehelyett dupla akkora pozitív egészeket tartalmaz 0-val kezdődően mint a sima int típus.           
	</para>
    </section>
		
    <section>
        <title>SamuCam</title>
        <para>
	     Mutassunk rá a webcam (pl. Androidos mobilod) kezelésére ebben a projektben: https://github.com/nbatfai/SamuCam
	</para>
        <para>            
            
            
            
            
            
            
