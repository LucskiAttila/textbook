<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, !</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>FUTURE tevékenység editor</title>
        <para>
             Javítsunk valamit a ActivityEditor.java JavaFX programon! https://github.com/nbatfai/future/tree/master/cs/F6 Itt láthatjuk működésben az alapot: https://www.twitch.tv/videos/222879467
        </para>
        <para>
             A Future projekt a városok jövőbeli kutatására irányult a város lakóira alapozva, hogy azok innovatív és környezettudatos technológiai megoldásokat használjanak mindennapi feladatai megoldásában és hosszú távú céljai elérésében. Az F6-os projekt arra készült hogy a hallgatók a napi tevékeknységeiket feljegyezzék ugye környezettudatosan. 
             Az F6 projekt java programozési nyelven írt programja az ActivityEditor.java így ezt kellessz fordítanunk és futtatnunk, de ehhez szükségesek a többi fájlok is a projektből, illetve társítani kell a JavaFX-es könyvtárakat is. Mivel ebből elég sokat fog használni a programunk így egy szkriptet készítettem hozzá run néven melynek segítségével fordítom és futtatom is a programot:
        </para>
        <programlisting><![CDATA[
             #!/usr/bin/env bash
             export PATH_TO_FX="/usr/share/openjfx/lib"
             java_modules="javafx.controls,javafx.graphics,javafx.media,javafx.swing,javafx.web"
             rm -f *.class
             /usr/lib/jvm/java-11-openjdk-amd64/bin/javac\
                 --module-path $PATH_TO_FX\
                 --add-modules=$java_modules ActivityEditor.java
             /usr/lib/jvm/java-11-openjdk-amd64/bin/java\
                 --module-path $PATH_TO_FX\
                 --add-modules=$java_modules ActivityEditor
             rm -f *.class
        ]]></programlisting>
        <para>
             Az F6 projektet pedig az alábbi módon tölthetjük le, és indíthatjuk el miután megírtuk a run szkriptet:
        </para> 
        <programlisting><![CDATA[
             git clone https://github.com/nbatfai/future.git
             cd future/cs/F6
             gedit run
             ./run
        ]]></programlisting>
        <para>     
             A feladat az volt hogy javítsunk valamit a kódon, így kibővítettem egy törlés funkcióval amivel törölhetjük a mappáit vagy fájlait a megjelenített könyvtárszerkezetnek a gyökér mappa kivételével, mivel azt az ActivityEditor programunkban hozzuk létre a fa gyökereként nem fájlból olvassuk be. Ahogy az Én magam elemet is létrehozzuk faelemként nem beolvasással hozzuk létre, így ez a két elem fog látszani ha elindeítjuk a programot a City, gaming.props, initF6actFS.sh, me.props, programming.props fájlok használata nélkül. A program könyvtárszerkezete működik a  gaming.props, initF6actFS.sh, me.props, programming.props fájlok használata nélkül is. 
        </para>
        <programlisting language="Java"><![CDATA[
             javafx.scene.control.MenuItem deleteMenuItem = new javafx.scene.control.MenuItem("Törlés");
             addMenu.getItems().add(deleteMenuItem);
	     deleteMenuItem.setOnAction((javafx.event.ActionEvent evt) -> {
             javafx.scene.control.TreeItem item = getTreeItem();
             if (item.getParent() == null ){
             System.out.print("Cannot remove the root node.\n");}
             else{
             java.io.File file = getTreeItem().getValue();
             item.getParent().getChildren().remove(item);
	     deleteDirectory(file);}});}
             public boolean deleteDirectory(java.io.File directory) {
             if(directory.exists()){
             java.io.File[] files = directory.listFiles();
             if(null!=files){
             for(int i=0; i<files.length; i++) {
             if(files[i].isDirectory()) {
             deleteDirectory(files[i]);}
             else {
             files[i].delete();}}}}
             return(directory.delete());} 
        ]]></programlisting>
	<para>
	     Létrehoztunk Törlés menüpontot deleteMenuitem néven majd hozzáadtuk a Menu objektumhoz, majd beállítottunk hozzá egy akciót, mely egy megfelelő esemény bekövetkezésekor hívódik meg. A getTreeitem függvénnyel lekérjük a kijelölt mappát, majd ellenőrizzük almappa e, ha nem akkor hibaüzenetet írunk hogy gyökékönyvtárat nem lehet törölni, ha almappa akkor a remove függvénnyel töröljük az adatszerkezetből, majd töröljük a gépről is, ehhez viszont fájlként kell kezelnünk, majd meghívjuk rá az általunk készített deleteDirectory függvényt. Ez azért szüskséges mivel törölni szeretnénk a kijelölt mappánkat almappáival fájlaival együtt, azaz tartalmával együtt és a delete csak üres mappákkra vagy fájlokra hívható meg. A deleteDirectory függvény úgy működik hogy először ellenőrizzük a paraméterül kapott fájlról hogy létezik e, ha nem akkor a return részhez ugrunk ami meghívja a delete függvényt a nem létező fájlra és hibaüzenetet kapunk a delete függvénytől. Ha viszont létezik a fájl akkor az alfájlait belértve az almappákat is belerakjuk egy tömbbe, majd meghívjuk egyessével a tömb elemeit és ha mappa akkor meghívjuk rá rekurzívan a függvényünket egyébként töröljük a fájlt, majd a mappákat a rekurzív függvényhívások kiértékelődésekor törlil a függvények.                              	
	</para> 
             mediaobject>
             <imageobject>
                 <imagedata fileref="future.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>	    
            
            
            
            
            
            
            
            
