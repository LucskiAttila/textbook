<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Juhász István - Magas szintű programozási nyelvek 1; olvasónapló</title>
      
        <para>
	   A szamitogepes nyelveknek megkulonboztetjuk a szintjeit, leteznek gepi nyelvek es magas szintu nyelvek. Minden processzornak van egy gepi nyelve, melyen vegrehajtja az utasitsaokat, azonban az altalunk irt magasszintu nyelveken irt kodon irt utasitasokat a processzor nem tudja vegrehajtani mivel nem gepi nyelven van irva, igy at kell alakitanunk gepi nyelvve. A magasszintu nyelvek peldaul a C, melyek sajat szintaktikai esz szemantikai tulajdonsagokkal rendelkeznek. A magasszintu nyevlek gepi nyelvekke alakitasara ket modszer van az egyik a forditoprogramos a masik az interpretes. A forditoprogramos atalikitast hasznaljuk mivel ellenorzi a kodot szintaktikailag es szematikailag mielott leforditana, ilyen peldaul a C nyelvhez a gcc, melynek tobb valtozoata ismert c90, c11, melyeknek neveiben az evjaratra utalnak a szamjegyek. A forditoprogram keszit targyprogramot, ha szintaktialag helyes a kodunk, melyet a gcc forditonal az -o kapcsoloval nevezhetunk el. Az interpretes forditassal a kod rogton lefut az ellenorzesek utan, mivel nem keszul targyprogram amit kesobb is futtathatunk. A programozasi nyelveket ket fobb osztalyba sorolhatjuk az egyik az inperativ nyelvek, melyekbe algoritmusok segitsegevel irjuk meg az utasitasokat kulonbozo valtozokat felhasznalva es van lehetosegunk memoriafoglalasra is, ezeket gyakroabban hasznaljuk ilyen peldaul a C nyelv. Vannak a deklarativ nyelvek amelyek nagyabol az inperativ nyelvekkel ellenkezo tulajdonsagokkal rendelkeznek, presze ezeken kivul leteznek meg maselvu nyelvek amelyek nincs egyseges jellemzojuk. Minden programnyelvnek sajat karakterkeszlete van mely betukbol, szamokbol es egyeb karakterekbol epul fel. A szamok altalaban egyseges decimalis szamok. A betuknel eltero lehet hogy kulon kezeli e a kis es nagybetuket mint peldaul a C nyelv. A specialis karakterek kozul a szokozt, tabulatort, entert nem kulonbozteti meg a fordito, ezeket egysegesen white space-knek nevezzuk, tehat mindegy melyiket hasznaljuk szo alkotasra szintaktikai szempontbol, azonban a jobb atlathatosag miatt hasznaljuk mindegyiket. A forrasprogramban elofordulo lexikalis egysegeket a lexikalis elemzes soran a fordito felismeri es tokenizalja azokat, ilyenek a tobbkarakteres szinbolumok peldaul C nyevlben a ++, a szimbolikus nevek amiket a programozo hoz letre az egyes elemek azonositasara, ezeknek a neveinek betu karakterekkel kell kezdodniuk es nem tartalmazhatnak speacialis karaktereket peldaul muveleti jeleket es a kulcsszok peldaul az if melynek a nyelv tulajdonit jelentest, megjegyzesek melyek segitik a program ertelmezest az olvaso szamara, a cimkek melyekkel a cimkezett utasitasra a program egy masik reszebol hivatkozni tudunk, literalok melyek megadjak a valtozo tipusat peldaul a double. Vannak kotott es szabad formatu nyelvek, a kotott formatumu nyelvekben egy sor egy utasitas ha nem fert ki egy sorba kulon jelezni kellett a sorvege torlesevel es a programelemeknek is meghatarozott helye van a sorban. A szabad formatumu elemeknel egy sorban akarhany utasitas kerulhet es tetszoleges poziciokban hasznalhatjuk a programelemeket, az utasitasok veget pedig pontosveeszovel jelezzuk. Az eljarasorientalt nyelvekbn a lexikalis egysegeket a megfelelo modon el kell valasztanunk egymastol whitespace-szel vagy elhatarolo jelekkel peldaul zarojellel. A kifejezesek segitsegevel egy adott ertekbol, operandusbol uj erteket hatarozunk meg operatorok segitsegevel, ehhez hasznalhatunk zarojelezest is hogy meghatarozzuk a muveleti sorrendet. A ketoperandusu kifejezesk alakjait az operator elhelyezkedese hatarozza meg, ha elol van akkor prefix alaku, ha kozepen infix, ha az operandusok mogott akkor postfix. A muveletek megfelelo sorrendbeli vegrehajtasa utan a kifejezesnek megkapjuk az uj erteket es hozzarendelodik a tipusa, ezt a kifejezes kiertekelesenek nevezzuk. A muveletek vegrehajtasi sorrendje lehet balrol-jobbra, jobbrol-balra, balrol-jobbra a precedenciatablazat segitsegevel. Mivel az infix alak operatorai nem azonos erosseguek igy az infix alak nem egyertelmu, ehhez hasznaljuk a precedenciatalbazatot, melynek muveleti sorrendjet felulirhatjuk zarojelek hasznalataval, a teljesen bezarojelezett alaknak egy muveletvegrehajtasi sorrednje van. A kifejezes tipusanak meghatarozasara ketfele modszer van, az egyik a tipusegyenloseg ekkor a ketoperandusu kifejezes mindeket erteke azonostipusu vagy az operator hatarozza meg a tipust. Ket programozasi eszkoz tipusa akkor azonos ha egy utasitasban dekralaltuk es azonos tipussal es a ket eszkoz osszetett tipusu, szerkezetuk megegyezik. A tipuskenyszerites moszerevel a ketoperandusu kifejezeseknek kulonbozo tipusu operandusai lehetnek, a muveletek viszont csak azonos tipusu operandusokkal vegezhetoek el igy annak megfeleloen atkonvertalodnak. A tipuskenyszeritesnek van boviteses fajtaja amikor a konvertalando tipus elemei elemei a celtipusnak is, szukites eseten viszont nem elemei es ekkor ertekcsonkitas vagy kerekites tortenik. Az utasitasok alkotjak az algoritmusok egyes reszeit, illetve a forditoprogram ennek segitsegevel generalja le a targyprogramot, ezek alapjan ket csoportjuk van dekralacios es vegrehajto utasitasok. A deklaracios utasitasok informaciot szolgaltat a targykod generalasahoz, a vegrehajto utasitasokat pedig leforditja targykodra. A vegrehajto utasitasokat kilenc csoportba sorolhatjuk. Az ertekado utasitas segitsegevel erteket adhatunk valtozoknak a program futasa alatt. Az ures utasitas segitesegevel a program egy ures gepi utasitast hajt vegre, ez szintaktikailag hasznos. Az ugro utasitas segitsegevel egy adott cimkevel ellatott utasitasnak adhatjuk at a vezerlest a GOTO parancs segitsegevel. Az elagaztato utasitas segitsegevel a program tobb tevekenyseg kozul hasznalja a megfelelot. A ciklusvezerlo utasitas segitsegevel a porgram egy adott tevekenyseget tobbszor is vegrehajthat, akar vegtelenszer is. C nyelvben a CONTINOU utasitas az aktualis ciklusszalbol kilep nem hatja vegre a tovabbi utasitast, hanem ujabb szalba kezd.

	</para>
    </section>        
    
    <section>
        <title>Kerninghan és Richie; olvasónapló</title>
        
        <para>
	A vegrehajtando muveletek sorrendjet a vezerlesatado utasitasok adjak meg. A kifejezesek vegere pontosvesszot teszunk hogy utasitaskent mukodjenek, egyebkent forditaskor szintaktikai hibat kapnank. Osszetettt utasitasokat letrehozhatunk, ha kapcsos zarojelek koze adunk meg tobb utasitast, ezek vegere nem kell pontosvesszo. Az if-else utasitas a parameterkent kapott kifejezes erteke alapjan donti el hogy vegrehajtja e a hozzarendelt utasitast, ha egy az erteke akkor vegrehajtja, nulla ertek eseten viszont nem hatja vegre, hanem ha adunk meg else agat annak az utasitasat hajtja vegre. Az if illetve az else vegrehajtja az utannauk kovetkezo utasitast vagy utasitasokat amit ugye kapcsoszarojelben kell megadnunk. Az if utasitasokat egymasba is agyazhatjuk egymasbol kovetkezo feltelek eseten, kapcsoszarojel hasznalata nelkul az else mindig a hozza legkozelebb esso if-hez tartozik. A kapcsos zarojel hasznalataval a beagyazott if utasitasok eseten az esle ag melyik if utasitashoz tartozasat is meghatarozhatjuk. Egy if utasitashoz egy else ag tartozhat ami hatekonyabban mukodik mint ket if utasitas hasznalata. Az else-if utasitasokban megadunk egy kezdo if utasitast majd akarhany elseif utasitast megadhatunk melyek egymas utan kiertekelodnek es ha az egyik erteke egy akkor vegrehajtja a hozzarendelt utasitast es kilep az else-if utasitasbol. Ha az if es minden else-if ag erteke nulla akkor ha van else ag akkor az ahhoz rendelt utasitas hajtodik vegre, ezt hasznaljuk hibakezeleskent is. A switch utasitast parameterekent megadunk egy kifejezest majd egy osszetett utasitasban megadjunk akarhany case ` ` : agat majd egy default: agat. A case ` ` reszeben megadunk egy allando erteku kifejezest melynek erteke ha megegyezik a switch parameterekent adott ertekkel akkor vegrehajtja a case : utan megadott utasitast. Ha egyetelen case eseteben megadott kifejezes erteke sem egyezik meg a switch parameterkent adott ertekevel akkor a default aghoz rendelt utasitas hajtodik vegre. A while utasitas a parameterekent megadott kifejezes erteket ellenorzi hogy egy e, ha igen akkor vegrehatja a hozzarendelt utasitast, majd ismet ellenorzi es egy ertek eseten ujra vegrehatja az utasitast, majd ezt addig hajtja vegre rekurzivan amig a kifejezes erteke nem lesz nulla. Ha a parameterkent adott kifejezes erteke egy akkor vegtelenszer hajtja vegre a while a hozzarendelt utasitast. Ha a prameterkent adott kifejezes tartalmaz valtozot, annak erteket modositjak a while utasitashoz rendelt utasitasok. A for utasitasnak harom kifezest adhatunk meg parameterul, melyek kozul az elso kezdoerteket ad a masdoik kifejezesben vizsgalt operandusnak, a masodik kifejezes operator segitsegevel eldonti nem nulla vagy nulla az aktualis erteke a kifejezenek, a harmadik kifejezzel pedig modsitjuk az elso parameterkent megadott valtozo erteket. A kifejezesek elhagyasaval es a harom pontosvesszo hasznalataval vegtelenszer fogja vegrehajtani a for utasitas a hozzarendelt utasitast. Minden for utasitast atirhatunk while utasitassa ugy hogy a for ciklus parameterekent megadott elso kifejezest a while ciklus elott definialjuk, a masodik kifejezes a while utasitas parametere lesz, a harmadik kifejezest pedig a while utasitashoz rendelt utasitasban definialjuk. A do-while utasitas a do utasitashoz rendelt utasitast hajtja vegre majd ellenorzi a while utasitas parametereul adott kifejezes erteket hogy nulla e ,ha nem ujra vegrehajtja a do utasitashoz rendelt utasitast majd ismet ellenorzi a while utasitas parametereul adott kifejezes erteket hogy nulla e, ezt hajtja vegre rekurzivan amig a while utasitas parametereul adott kifejezes erteke nulla nem lesz. A for es a while utasitassal ellentetben nem az utasitas vegrehajtasa elott ellenorzi hogy vegrehajtja e vagy nem, hanem eloszor vegrehajtja az utasitast majd ellenorzi hogy vegrehajtja e ujbol. A while ciklushoz hasonloan itt is az utasitas reszben valtozhat a valtozo erteke, amit operanduskent hasznal a while utasitas parameterekent megadott kifejezes. A do utasitashoz rendelt utasitast celszeru kapcsoszarojelben hasznalni hogy biztosan a while utasitashoz tartozzon. A break utasitas segitsegevel kilep a for, while, do-while, switch utasitasokbol a lefordulasakor, tehat nem addig hajtodik vegre amig a kifejezes erteke nulla nem lesz hanem addig amig a break utasitas le nem fordul. A countinu utasitas a for, while, do-while utasitasokhoz tartozo utasitasbol kilep es ismet a parameterkent adott kifejezes vagy kifejezesek erteke alapjan donti el hogy ujra lefut e az ugye for vagy while utasitashoz rendelt utasitas. Tehat a for es a while utasitasokhoz rendelt utasitasoknak az utasitasai a countinou utasitas lefutasaig hajtodnak vegre, nem a teljes utasitas utolso utasitasaig. A goto utasitast a tobbszorosen egymasba agyazott utasitasokbol valo kilepesre hasznaljuk ugy hogy az adott utasitasban megadott goto cimke nevu utasitas vegrehajtodasakor a cimke nevu cimkehez tartozo utasitasra ugrik a program. Cimket a cimkeneve : utasitas paranccsal hozhatunk letre. A goto utasitas hasznalataval csak az adott fuggvenyben cimkezett utasitas erheto el. A goto hasznalata kikerulheto megfelelo seged utasitasok hasznalataval. 
	</para>
    </section>        
    <section>
        <title> BME: Szoftverfejlesztés C++ nyelven / Benedek Zoltán, Levendovszky Tihamér ; olvasónapló</title>
        
        <para>
	A konyvtarakban van definialva a hiba, melyeket megfeleloen kezelhetunk, az ilyen definialt hibakat kiveteleknek azaz exeption-nak nevezzuk. A kivetelkezesles ugy tortenik hogyha egy fuggveny nem tud kezelni egy hibat kivetelt dob ra a throw fuggvennyel melyet a catch fuggvennyel elkaphatunk ha megfelelo kivetelt definialtunk. Hibakezelesnel nelkul a program hiba eseten leall vagy hibasan mukodik. A C++ programoknak az alapveto hibakezelese hogy hiba eseten a program leall, kiveve ha a el nem kapjuk az osszes hibat es megfeleloen kezeljuk hogy ne alljon le. A  C programoknal viszont tovabb fut hibasan is, es igy csak kesobb derulhet ki a hiba esetleges leallas eseten. A kivetelkezeles a szinkron kivetelek kezelesere szolgal pedlaul a ki es bemeneti hibak, az aszinkron esemenyeket pedlaul a billentyuzet felol erkezo hibat szignalokkal kezeljuk. A kivetel elofordulast egy osztallyal irjuk le melynek egy objektuma a kivetel. Van ugynevezett vegrehajtasi verem mely a throw fuggveny meghivasaval tekerodik vissza a catch fuggvenyig. A kivetelek osztalyait hierarikusan kezeljuk hogy egyszerubben tudjuk modositani azokat. A kivetelket csak akkor tudjuk elkapni ha a catch parameterenek tipusa megegyezik a throw-val meghivottnak, vagy ha a catch parametere foosztalya a throw-val meghivottnak, vagy ha a catch parametere es a throw-ra meghivott is mutatotipus melyeknek vagy megegyezik a tipusuk vagy a catch parametere bazisosztalya a throw-val meghivottnak, vagy ha a catch parametere referencia es teljesul ra hogy megeyezik a tipusa a throw-val meghivotteval vagy bazisosztalya a throw-val meghivottnak. A const szo hasznalataval a kivetelek erteket nem valtoztathatjuk es minden kivetel masolhato. Ha nem tudjuk kezelni teljes egeszeben az elkapott kivetelt akkor tovabdobhatjuk a throw utasitas lefuttatasaval, ekkor nem az elkapott kivetelt dobjuk tovabb hanem az eredeti throw altal dobottat. A try fuggvenyben definialjuk a catch fuggvenyeket, melyeknek a sorrendje osztaly hierarhia szerint novekvo sorrendben kell legyen mivel ekkor az alosztalyok nem kapodnanak el. Fajlkezelesnel a megnyitott fajlt nem mindig zarul automatikusan, mivel ha a hiba az fclose meghivodasa elott van akkor a hibat kezelhetjuk a use_file() fuggveny visszateresi erteket ad a hibat felismero fuggvenynek, de az fclose fuggveny mar nem hivodik meg igy a lefoglalt memoriaelfolyik. Ezt a hibat javithatnank ugyis hogy a catch fuggvennyel elkapunk minden kivetelt es meghivjuk benne az fclose fuggvenyt, de ez nagyobb kodoknal bonyolultabb igy osztalyban definialjuk a fajlkezelest melynek a destruktora elvegzi a megfelelo memoriafelszabaditast a kivetelkezelestol fuggetelenul. A hasznalatos objektumokat lokalis objektumkent hozzuk letre a konstruktor inicializacios listajaval, mivel a konstruktor segitsegevel letrehozott objektumot torli a destruktor es az igy letrehozott objektum teljesen jon letre megfeleloen megirt konstruktor eseten. Az inicializaios lista hasznalataval a fordito ellenorzi hogy a letrehozott objektumok letrehozasa kozben kivetel adodik akkor csak a letrehozott objektum torlodik, igy nem szukseges a konstruktor irashoz kivetelkezelo kod. Ha csak egy objektum resz jon letre mivel kivetel van a konstruktor parameterben akkor nem jon letre teljesen az objektum igy a destruktor nem torli, ehelyett inicializasios lista segitsegevel vektort hasznalunk az objektum memoriakezelesehez. Az std konyvtarban van auto_ptr kisebbkacsacsor nagyobbkacsacsor sablon mely a kisebbkacsacsor nagyobbkacsacsor kozott megadott tipussal hoz letre mutatot az adott objektumra, hasonloan mukodik a hagyomanyos mutatokhoz, de torlesekor megsemmisul az altala mutatott objektum is. Az auot_ptr egy masik mutatoba masolasval a mutato nem mutat semmire es az auto_ptr-eket a masoolas megvaltoztatja, de hasznalhatjuk ra a const kulcsszot melynek segitsegevel nem lesz masolhato. Ezt az auto_ptr_ref akadalyozza meg es megvalositsa a masolasukat. Nem std tipusuokkal valo masolasa peldaul vektorba masolaskor serules veszely all fenn. Az auto_ptr altal mutatott objektum torlodik a kivetelkezeletol fuggetlenul. Elhelyezo utasitas hasznataval kivetelkezeleskor is felszabadul a new altal lefoglalt hely a megfelelo delete parancsokkal automatikusan, mas modon lefoglalt memoriarat nem szabadit fel automatikusan. Ha elfogy a memoria a memoriaszivargasok miatt akkor kivetelkezelessel es egy vegtelen ciklussal hasznalt malloc fuggveny segitsegevel kereshetunk memoriacimeket, melyeket a tulterhelt new fuggveny ad vissza, ha nem talal hibakezelest hasznalunk. A bad_alloc kivetelt melynek mukodsehez marad memoria, es a new_hanler-t hivjuk meg elotte ha nem talal memoriat a malloc. A konstruktoroknak alapvetoen nincs visszateresi ertekuk igy hibas allapotu objektumot hozhatunk letre vagy globalis valtozoval ellenorizzuk az objektum letrehozas sikeresseget vagy ne hozzunk letre kezdeti erteket vagy kezdeti ertek helyett egy tagfuggveny adjon erteket mely jelenti a hibat. Ezeknek a felhasznaloi ellenorzesevel kivetelkezelhetjuk a konstruktorokat. A destruktor meghivodhat a verem visszatekerese kozben ha elhagyunk egy megfelelo objektumot. Ha egy kivetelt nem kapunk el akkor a terminate fuggveny kerul meghivasra vagy ha a kivetelkezelo eljaras a vermet hibasnak talalja vagy egy delete kivetel kivaltassal probal veget erni. A terminate fuggveny meghivodasa meghivja az abort fuggvenyt amely kilep a programbol nem feltetlenul szabalyosan es az exit fuggvennyel ellentetben ennek nincs visszateresi erteke arrol hogy szabalyosan allt e le a program vagy nem. Egy elakapott kivetel nem mindig jelenti a program hibajat.
	</para>
   </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  
</chapter> 
