<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Lauda!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>

    <section>
        <title>Port scan</title>
        <para>
            Mutassunk rá ebben a port szkennelő forrásban a kivételkezelés szerepére! https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok javat/ch01.html#id527287
        </para>
        <para>
            A kivételkezelés segítségével tájékoztassuk a felhasználót arról hogy miért működik hibásan a program. Erre minden programozási nyelv biztosít lehetőséget, mivel írhatunk saját kivlteket is például if szerkezettel hogy 0-val ne osszunk, így mivel kezeltük a kivételt a program akár tovább is működhet leállás nélkül, de előfordulhatnak olyan esetek is hogy a program hibásan működhet tovább hibakezelés nélkül, nem csak leálláskor van szükség hibakezelésre. A nem objektum-orientált programozási nyelvekben mint például a C minden kivételt külön kell kezelnünk, a modernebb obejktum-orientált progrmaozási nyelvekben mint a C++ vagu ugye a Java már egy blokkban kezelhetjük az összes feltételt. Erre szolgál a try{} catch(kivétel deklaráció){} ... finally{}, ahol a try blokkba rakjuk a szöveget ahol a kivételt keressük, a cahtch blokkokba pedig megnevezzük a kivételeket amelyeket keresünk a kódban és leírjuk hogy mit csináljon a program az adott kivétel elkapásakor, akár több kvételt is definálhatunk mivel több catch blokkot használhatunk. Ekkor ugye kivételenként egy catch-et használunk, ahol a kivételek hierarchikusan növekvő sorrendben kell hogy szereplejenek öröklődés szempontjából, mert akkor az általunk használni kívánt alosztályos már nem kapódna el, mert az ősösztálya elkapta. A finally részben megadott utasítások mindenképp lefutnak kivétel találásától függetlenül. A throw kulcsszóval pedig dobhatunk kivételeket, amelyek Java-ban a Throwable osztály leszármazottjai, de mi is hozhatunk létre átlalunk definált kivételeket valamelyik Java kivétel osztály leszármazottjaként, ezeket a throw someThrowableObject; módon kell használni, ahol a throw után dobható objektumot hozunk létre vagy nevezünk meg. Ezeknek az elkapásához szükség esetén a függvénynek amikbe vannak a deklarásakor throws someThrowableClass-t írjuk a paraméterlistája után, mivel ezeket nem ebben a függvényben, hanem például az adott függvényt meghívó függvényben vagy akár a main-ben fogjuk kezelni, elkapni. Java programozási nyelvben fontos szerepe van a kivételkezelésnek mivel ennek elhagyásával akár nem is engedheti a fordítást hibát jelezve a fordító fordításkor azaz a Java VM. Ez történne az alábbi kódban is kivételkezelés nélkül:
        <programlisting language="java"><![CDATA[
            public class KapuSzkenner {
                public static void main(String[] args) {    
                    for(int i=0; i<1024; ++i;
                        try {
                            java.net.Socket socket = new java.net.Socket(args[0], i);
                            System.out.println(i + " figyeli");
                            socket.close();
                        } catch (Exception e) {
                            System.out.println(i + " nem figyeli, mivel: "+e);
                        }
                }
            }   
        ]]></programlisting>    
            A kódban ellenőrizzük hogy a futtatáskor parancssori argumentumként megadott ip cím 0 és 1024 közti portjain hány tcp kapcsolatot tudunk létrehozni és ezekhez csatlakozni a gépónkről. Ezzel ne nagyon kísérletezzünk mert támadásnak is vehetik egyes ip címeneket használva. Amint látjuk a forráskódból siker esetén kiírjuk hogy figyeli az adott számú portot, majd bezárjuk a kapcsolatot, hiba esetén kiiratjk hogy nem figyeli az adott számú portot. Amint láthatjuk VirtualBox alatt nem sikerült kapcsolatot létesítenem az elkapott hibaüzenet alapján, pedig próbáltam $HOSTNAME és localhost parancssori argumentumokkal is, lehet a tűzfal a probléma. 
        </para>
             mediaobject>
             <imageobject>
                 <imagedata fileref="portscan.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>

    <section>
        <title>AOP</title>
        <para>
            Szőj bele egy átszövő vonatkozást az első védési programod Java átiratába! (Sztenderd védési feladat volt korábban.)
        </para>
        <para>
            Átszövő vonatkozásokat az AOP azaz aspekum orientált programozási nyelvek segítségével kéeszíthetünk, ilyen például az AspectJ programozási nyelv ami a Java programozási nyelvhez tartozik. Ennek a programozási nyelvnek a segítségével a már Java programozási nyelven megírt programkódot felhasználva módosításokat végezhetünk a program egyes részein külön programban így nem módosul az eredeti Java kód. Ezeket a módosításokat úgynevezett átszövések segítségével hajtjuk végre melyek hasonlítanak a más programozási nyelvekbeli osztályokra. Ezekben az átszövésekben használhatunk többféle függvényt a módosítások elvégzéséhez, például ha egy Java programozási nyelven megírt forráskód függvénye előtt vagy után akarunk plusz utasításokat elhelyezni akkor a pointcut függvényt használjuk. Ha viszont egy Java programozási nyelven megírt forráskód függvényt szeretnénk módosítani akkor az around függvényt használjuk. A feladat megoldásához is ezt használtam mivel elkészítettem az LZWBinfa preoreder bejárását és ehhez módosítanom kellett a kiirató függvényt:
        <programlisting language="java"><![CDATA[
        privileged aspect Aspect{
            void around(LZWBinFa fa, LZWBinFa.Csomopont elem, java.io.BufferedWriter os):
                call(public void LZWBinFa.kiir(LZWBinFa.Csomopont, java.io.BufferedWriter)) 
                    && target(fa) && args(elem, os){
                if (elem != null)
                {
                    try{
                        ++fa.melyseg;
                        for (int i = 0; i < fa.melyseg; ++i)
                            os.write("---");
                        os.write(elem.getBetu () + "(" + (fa.melyseg - 1) + ")\n");
                        fa.kiir(elem.nullasGyermek (), os);
                        fa.kiir(elem.egyesGyermek (), os);
                        --fa.melyseg;
                    }
                    catch(java.io.IOException e){
                        System.out.println("Csomópont írása nem sikerült, mivel: "+e);
                    }
                }
            }
        }
        ]]></programlisting>            
            Amint láthatjuk az egész program egy osztályban van mivel objektum-orientált programozási nyelvről van szó, és mivel apskeutust írunk így már a claas kulcsszó helyett aspect-et kell használnunk. A privileged típussal hoztuk létre az Aspect osztályunkat mivel szeretnénk hozzáférni a Java programozási nyelven megírt forráskódunk osztályának privát részeihez is. Amint már említettem az around függvényt fogjuk használni mivel az általunk módosítani kívánt függvény azaz a kiir(Csomopont, BufferedWriter) nem statikus azaz nincs a memóriában így az aspektusunk nem éri el, ezért az around függvény paramétereiben példányosítjuk a használatos objektumokat vesszővel elválasztva. Majd a : utám megadjuk hogy a call függvény paramétereként hogy melyik függvényét használjuk majd a Java programozási nyelven megírt forráskódunknak a megfelelő paraméterekkel. Majd && jelek után megadjuk a target függvényben megadjuk hogy melyik around paraméterei közül kiválasztott objektumra fogjuk használni a meghívott kiir függvényt. majd && után az args függvény paramétereként megadjuk hogy az around paraméterei közül melyeket használja a kiir függvény paraméterként. Az around függvény törzséen pedig a már általunk ismert preorder bejárást valósítjuk meg a megfelelő sorok felcserélésével az eredeti kód alapján. A preorder rendezésnél ugye először kiírjuk az eredményt, mivel a gyökértül indulunk, majd meghívjuk a bal oldali elemét, majd ha elfogy akkor a jobb oldalit rekúrzívan. A programnkat hibakezeltem egy be-kimeneti hibákat kezelő osztállyal, mely hiba esetén hibaüzenetet ík ki. A program futtatásához az alábbiakat kell tennünk:
        <programlisting language="java"><![CDATA[
            sudo apt install aspectj
            ajc LZWBinFa.java Aspect.aj
            java -cp /usr/share/java/aspectjrt.jar:. LZWBinFa input.txt -o output.txt
        ]]></programlisting>
        </para>
             mediaobject>
             <imageobject>
                 <imagedata fileref="aop.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>            
            
    <section>
        <title>Anroid Játék</title>
        <para>
            Írjunk egy egyszerű Androidos „játékot”! Építkezzünk például a 2. hét „Helló, Android!” feladatára!
        </para>
        <para>            
            
        </para>
             mediaobject>
             <imageobject>
                 <imagedata fileref="android.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section> 

    <section>
        <title>Junit teszt</title>
        <para>
            A https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat poszt kézzel számított mélységét és szórását dolgozd be egy Junit tesztbe (sztenderd védési feladat volt korábban)
        </para>
        <para>            
            A feladat alapján Unit keretrendszert kell használnunk, melynek segítségével teszteket hajthatunk végre egy Java programozási nyelven megírt forráskódon, tehát ellenőrizhetjük hogy a programunk egyes függvényei a vártnak megfelelő értékekkel tértek e vissza. A feladatunk az volt hogy ellenőrizzük a binfa által kiszámított értékeket egy adott sztringre, ehhez a kiszámolt értékeket az alábbi linken találhatunk például: https://progpater.blog.hu/2011/03/05/labormeres_otthon_avagy_hogyan_dolgozok_fel_egy_pedat . Ezt a linket láthatjuk a feladat szövegében is, ehhez az alábbi kódot készítettem:
        <programlisting language="java"><![CDATA[
                import static org.junit.jupiter.api.Assertions.*;
                import org.junit.jupiter.api.Test;
                
                public class LZWBinFaTest {
                LZWBinFa binfa = new LZWBinFa();             
                String str = "0111100101100";
                @Test
                public void atlagTest() {
                    for(int i = 0; i < str.length(); i++){
                        binfa.push_back(str.charAt(i));
                    }
                    double atlag = binfa.getAtlag();
                    assertEquals(2.25, atlag, 0.001);
                }
                @Test
                public void szorasTest() {
                    for(int i = 0; i < str.length(); i++){
                        binfa.push_back(str.charAt(i));
                    }
                    double szoras = binfa.getSzoras();
                    assertEquals(0.5, szoras, 0.001);
                }
                @Test
                public void melysegTest() {
                    for(int i = 0; i < str.length(); i++){
                    binfa.push_back(str.charAt(i));
                    }
                    double melyseg = binfa.getMelyseg();
                    assertEquals(3, melyseg);
                    }
                }
        ]]></programlisting>    
        Amint láthatjuk a kódunk sima Java programozási nyelven írt kódnak néz ki, de tartalmaz @Test makrót mely arra utal hogy teszt függvényt használunk, de ezek előtt példányosítanunk kell egy binfa objektumot, mivel minden @Test függvény külön objektumot fog használni az ellenőrzéshez. A teszt függvényekben egy for ciklussal végigmegyünk a bemeneti sztringen és karaktereknént beolvassuk a binfa-ba, majd ellenőrizzük az assertEquals függvénnyel hogy a binfa adott függvénye megegyezik e az adott értékkel. Ezeket az első kétparaméterében adjuk meg, de megadhatunk egy harmadik paramétert is mely a két hasonlítandó érték közti maximum eltérést jelenti. Ez utóbbi használata akkor szükséges ha nem egész értékeket számolunk, lebegőpontos számításokat végezve a kerekítések miatt.
        </para>
             mediaobject>
             <imageobject>
                 <imagedata fileref="unittest.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>

    <section>
        <title>OSCI</title>
        <para>
            Készíts egyszerű C++/OpenGL-es megjelenítőt, amiben egy kocsit irányítasz az úton. 
        </para>
        <para>            
            
        </para>
             mediaobject>
             <imageobject>
                 <imagedata fileref="osci.png"></imagedata>
             </imageobject>
         </mediaobject>
    </section>
</chapter>
            
