<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Turing!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Végtelen ciklus</title>
        <para>
            Írj olyan C végtelen ciklusokat, amelyek 0 illetve 100 százalékban dolgoztatnak egy magot és egy olyat, amely  
            100 százalékban minden magot!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  src/Infinite/*   
        </para>
        <para>
            Ha tisztában vagyunk egy kicsit is a számítógépek működésével
            akkor egyből láthatjuk, hogy ennek a feladatnak a megoldása triviális, ugyanis
            100%-os leterheltséget akkor érünk el, ha "szünet" nélkül dolgoztatjuk a CPU-t.
        </para>
        <para>
            Ehhez pedig nem kell mást írnunk mint egy végtelen ciklust egy adott programozási nyelvben, jelen esetben
            a C programozási nyelvben:
        </para>
        <programlisting language="c">
            <![CDATA[
            int main()
            {
                    for(;;)
                    {
                
                    }
                    return 0;
            }
            ]]>
        </programlisting>
        <para>
            Fordításkor az <application>infTRUE100</application> nevet adtam neki.
            A programot indítsuk el a háttérben, majd
            a <command>ps aux | grep inf</command> paranccsal győződjünk meg arról, hogy a várt 100%-os terhelést elértük-e ezzel a megoldással!
        </para>
        <screen>
            <![CDATA[
                tomi@cant0r:~/Dev/bhax/src$ ./infTRUE100&
                [1] 22771
                tomi@cant0r:~/Dev/bhax/src$ ps aux | grep inf
                tomi     22771 99.2  0.0   2316   684 pts/1    R    19:10   0:07 ./infTRUE100
                tomi     22775  0.0  0.0  20352   896 pts/1    S+   19:10   0:00 grep --color=auto inf
                tomi@cant0r:~/Dev/bhax/src$ ps aux | grep inf
                tomi     22771  107  0.0   2316   684 pts/1    R    19:10   0:09 ./infTRUE100
                tomi     22777  0.0  0.0  20352   828 pts/1    S+   19:10   0:00 grep --color=auto inf
                tomi@cant0r:~/Dev/bhax/src$ 
            ]]>
        </screen>
        <para>
            Ahogyan a kimenet 3. oszlopában látjuk, elértük a 100%-os terhelést.
        </para>
        <para>
            Hogyan érjük el a 0% terhelést? Egyszerűen változtassuk meg a fenti C kódot a következőképpen:
        </para>
        <programlisting language="c">
            <![CDATA[
            #include <unistd.h>
            
            int main()
            {
                    for(;;)
                    {
                        sleep(1);
                    }
                    return 0;
            }
            ]]>
        </programlisting>
        <para>
            Ekkor a program minden iterációban vár egy kicsit a <function>sleep(n)</function> meghívásával, ami azt eredményezi, hogy
            lelassítja az iterálás sebességét, tehát nem éri "teljes" terhelés a CPU-t.
            Lásd <command>man 3 sleep</command> további információkért a sleep(n)-ről.
        </para>
        <screen>
            <![CDATA[
                tomi@cant0r:~/Dev/bhax/src$ ./infTRUE100&
                [1] 22870
                tomi@cant0r:~/Dev/bhax/src$ ps aux | grep inf
                tomi     22870  0.0  0.0   2316   748 pts/1    S    19:20   0:00 ./infTRUE100
                tomi     22872  0.0  0.0  20352   888 pts/1    S+   19:20   0:00 grep --color=auto infTRUE100
                tomi@cant0r:~/Dev/bhax/src$ 
            ]]>
        </screen>
        <para>
            Ahhoz, hogy minden magon 100%-os kihasználást lássunk, a fenti programot egyszerre annyiszor kell futtattni amennyi magunk van, vagy szálasítunk!.
        </para>
        <para>
            Az első esetben egyik standard gondolatunk, ha UNIX szerű rendszert használunk, hogy megvillázuk (forkoljuk) a processzust ezzel másolatokat készítve a futó processzusról.
            A magok számát az <application>nproc</application> programmal egyszerűen lekérdezhetjük. E könyv elején megadott hardver esetében:
        </para>
        <screen>
            <![CDATA[
               tomi@cant0r:~/Dev/bhax/src/Infinite$ nproc
               4
               tomi@cant0r:~/Dev/bhax/src/Infinite$ 
            ]]>
        </screen>
        <para>
            A kinyert információ alapján létrehozzuk a következő C forráskódot, majd lefordítjuk a kedvenc C fordítónkkal. <command>gcc -o inf infTRUE100.c</command>
        </para>
        <programlisting language="c">
            <![CDATA[
                #include <unistd.h>
                #include <sys/types.h>

                int main()
                {
                    int p1, p2, p3;

                    if(!(p1 = fork()))
                    {
                        for(;;);
                    }
                    if(!(p2 = fork()))
                    {
                        for(;;);
                    }
                    if(!(p3 = fork()))
                    {
                        for(;;);
                    }

                    for(;;);

                    return 0;

                }
            ]]>
        </programlisting>
        <para>
            Futassuk és nézzük meg az eredményt <application>top</application> alkalmazás felhasználásával!
        </para>
        <screen>
            <![CDATA[
                tomi@cant0r:~/Dev/bhax/src/Infinite$ ls
                infTRUE100  infTRUE100.c
                tomi@cant0r:~/Dev/bhax/src/Infinite$ ./infTRUE100 

            ]]>
        </screen>
        <screen>
            <![CDATA[
                top - 15:57:11 up  1:30,  1 user,  load average: 1,34, 0,84, 0,90
                Tasks: 237 total,   5 running, 232 sleeping,   0 stopped,   0 zombie
                %Cpu0  :100,0 us,  0,0 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu1  : 99,3 us,  0,7 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu2  :100,0 us,  0,0 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu3  :100,0 us,  0,0 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                MiB Mem :   7869,0 total,   3025,2 free,   1891,9 used,   2951,9 buff/cache
                MiB Swap:  15258,8 total,  15258,8 free,      0,0 used.   5342,4 avail Mem 
            ]]>
        </screen>
        <para>
            Ha szálasítani akarunk érdemes valamilyen kész megoldást használnunk, pl: OpenMP. Nyilván ezenkívül rengeteg ismert vagy ismeretlen solution áll rendelkezésünkre, de egyszerűsége miatt ennél
            a feladatnál az előbb említett library szolgáltatásait vesszük igénybe.
        </para>
        <para>
            A munkagépen, az én esetemben, a GNU Compiler Collection van telepítve ami alapértelmezetten támogatja az OpenMP könyvtárat.
            Írjuk meg és fordítsuk le a következő C kódot a
        </para> 
        <para><command>gcc -o infOPEN infOPEN.c -fopenmp</command></para>
        <para>paranccsal, majd ismételjük meg a fentebb tett ellenőrzéseket!</para>
        <programlisting language="c">
            <![CDATA[
            #include <omp.h>

                int main()
                {
                    #pragma omp parallel
                    {
                        for(;;);
                    }

                    return 0;

                }            
            ]]>
        </programlisting>
        <screen>
            <![CDATA[
                tomi@cant0r:~/Dev/bhax/src/Infinite$ gcc -o infOPEN infOPEN.c -fopenmp
                tomi@cant0r:~/Dev/bhax/src/Infinite$ ls
                infOPEN  infOPEN.c  infTRUE100  infTRUE100.c
                tomi@cant0r:~/Dev/bhax/src/Infinite$ ./infOPEN 
                ^C
                tomi@cant0r:~/Dev/bhax/src/Infinite$ 
            ]]>
        </screen>
        <screen>
            <![CDATA[
                top - 16:18:43 up  1:51,  1 user,  load average: 1,05, 0,86, 0,85
                Tasks: 234 total,   2 running, 232 sleeping,   0 stopped,   0 zombie
                %Cpu0  :100,0 us,  0,0 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu1  : 99,7 us,  0,3 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu2  : 99,7 us,  0,3 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                %Cpu3  :100,0 us,  0,0 sy,  0,0 ni,  0,0 id,  0,0 wa,  0,0 hi,  0,0 si,  0,0 st
                MiB Mem :   7869,0 total,   2955,0 free,   1883,9 used,   3030,1 buff/cache
                MiB Swap:  15258,8 total,  15258,8 free,      0,0 used.   5334,7 avail Mem 
            ]]>
        </screen>
    </section>
        
          
    <section>
        <title>Lefagyott, nem fagyott, akkor most mi van?</title>
        <para>
            Mutasd meg, hogy nem lehet olyan programot írni, amely bármely más programról eldönti, hogy le fog-e fagyni vagy sem!
        </para>
        <para>
            Megoldás videó:
        </para>
        <para>
            Megoldás forrása:  tegyük fel, hogy akkora haxorok vagyunk, hogy meg tudjuk írni a <function>Lefagy</function>
            függvényt, amely tetszőleges programról el tudja dönteni, hogy van-e benne vlgtelen ciklus:              
        </para>
        <programlisting language="c"><![CDATA[Program T100
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	main(Input Q)
	{
		Lefagy(Q)
	}
}]]></programlisting>            
        <para>
            A program futtatása, például akár az előző <filename>infTRUE100.c</filename> ilyen pszeudókódjára:
            <screen><![CDATA[T100(t.c.pseudo)
true]]></screen>            
            akár önmagára
            <screen><![CDATA[T100(T100)
false]]></screen>  
            ezt a kimenetet adja.          
        </para>
        <para>
            A T100-as programot felhasználva készítsük most el az alábbi T1000-set, amelyben a
            Lefagy-ra épőlő Lefagy2 már nem tartalmaz feltételezett, csak csak konkrét kódot:
        </para>
        <programlisting language="c"><![CDATA[Program T1000
{

	boolean Lefagy(Program P)
	{
		 if(P-ben van végtelen ciklus)
			return true;
		 else
			return false; 
	}

	boolean Lefagy2(Program P)
	{
		 if(Lefagy(P))
			return true;
		 else
			for(;;); 
	}

	main(Input Q)
	{
		Lefagy2(Q)
	}

}]]></programlisting>            
        <programlisting><![CDATA[]]></programlisting>            
        <para>
            Mit for kiírni erre a <computeroutput>T1000(T1000)</computeroutput> futtatásra?
                                
            <itemizedlist>
                <listitem>
                    <para>Ha T1000 lefagyó, akkor nem fog lefagyni, kiírja, hogy true</para>                        
                </listitem>
                <listitem>
                    <para>Ha T1000 nem fagyó, akkor pedig le fog fagyni...</para>                        
                </listitem>
            </itemizedlist>
            akkor most hogy fog működni? Sehogy, mert ilyen <function>Lefagy</function>
            függvényt, azaz a T100 program nem is létezik.                
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...:
        </para>
         <para>
            Akár forráskódok nélkül is tekinthetünk a problémára és még egyszerűbben is láthatjuk, hogy ellentmondásra jutunk, ilyen gép/algoritmus/.. nem létezhet.
        </para>
            <para>Tételezzük fel, hogy létezik olyan program(King) ami el tudja dönteni a beolvasott bemenetéről, hogy végtelenségig fog-e futni vagy sem.
            (Ha a bemenet meg fog állni egy ponton futása során, akkor térjen vissza egy "Igen"-nel, ha nem, akkor egy "Nem"-mel.)
            </para>
          <para>
              Hozzunk létre egy új programot(Doctor Landau) ami az előző program(King) szolgáltatásaira épül,
              ha a King-től egy "Igen" választ kap vissza, akkor nem áll meg végtelen ciklusba lép, ha "Nem"-et, akkor megáll.
          </para>
          <para>
            Innen már láthatjuk is az ellentmondást.
          </para>
          <para>
              Mi van akkor ha ezt az új programot "megetetjük" önmagával, tehát magát kapja meg argumentumként?
          </para>
          <para> 
            Két eset lehetséges:
          </para>
          <para>
            Doctor Landau megáll, de ez csak akkor lehetséges, ha Doctor Landau(argumentum) nem áll meg, de az csak akkor ha Doctor Landau(argumentum argumentuma) megáll...</para>
          <para>Doctor Landau nem áll meg, de ez csak akkor lehetséges, ha Doctor Landau(argumentum) megáll, de ez csak akkor ha Doctor Landau(argumentum argumentuma) nem áll meg...</para>
          <para>Ellentmondásra jutottunk, King hazudott, azaz hibásan működik, tehát nem létezik erre a problémára megoldás.</para>
         
        <para>
            Azaz, feltételeztük, hogy létezik ilyen program, de paradoxonra jutottunk, tehát hibás a feltételezésünk.
        </para>
    </section>        
                
    <section>
        <title>Változók értékének felcserélése</title>
        <para>
            Írj olyan C programot, amely felcseréli két változó értékét, bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk">https://bhaxor.blog.hu/2018/08/28/10_begin_goto_20_avagy_elindulunk</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <programlisting language="c">
            <![CDATA[
#include <stdio.h>

#define val1 1986 
#define val2 2033

signed int temp;

void swap(int*,int*, int);

int main()
{
    int a = val1, b = val2;
    
    //e C forrás miatt Uncle Bob törné ujjaimat
    
    printf("================================\n");
    printf("Változók felcserélés, a program.\n");
    printf("================================\n\n");
    
    printf("Csere összeadással/kivonással:\n");
    
    printf("Kezdeti értékek:\t a=%d b=%d\n", a, b);
    swap(&a,&b,0);
    printf("Csere után:\t\t a=%d b=%d\n\n", a, b);
    
    
    printf("Csere XOR-ral:\n");
    
    printf("Kezdeti értékek:\t a=%d b=%d\n", a, b);
    swap(&a,&b,1);
    printf("Csere után:\t\t a=%d b=%d\n\n", a, b);
    
    printf("Csere segédmunkással:\n");
    
    printf("Kezdeti értékek:\t a=%d b=%d\n", a, b);
    swap(&a,&b,2);
    printf("Csere után:\t\t a=%d b=%d\n\n", a, b);
    
    return 0;
}
void swap(int* a,int* b, int swapMode)
{
    switch(swapMode)
    {
        case 0: 
            *b = *b - *a;
            *a = *a + *b;
            *b = *a - *b;
            return;
        case 1:
            *b = *a ^ *b;
            *a = *a ^ *b;
            *b = *a ^ *b;
            return;
            
        default:
            temp = *a;
            *a = *b;
            *b = temp;
            return;
    }
}

    
            ]]>
        </programlisting>
        <para>
            Tanulságok, tapasztalatok, magyarázat...:
        </para>
        <para>
            A legtöbbet használt módszerek a változók értékeinek felcserélésére az új változókkal való csere, az XOR művelettel való csere és az összeadás/kivonás műveleteivel törénő csere.
        </para>
        <para>
            Sokat nem lehet beszélni róluk, viszont röviden működésüket érdemes átnézni.
        </para>
        <para>
            A kedvenc, legtöbbet általam igénybevett módszerem, az XOR csere.
        </para>
        <para>
            Az XOR, vagyis a kizáró vagy, igazat ad vissza ha egyik, vagy a másik vizsgált dolog igaz, de nem mind a kettő.
        </para>
        <para>
            E tényt felhasználva történik a csere. Nézzünk egy példát:
        </para>
        <para>
            a=0011
        </para>
        <para>
            b=0111
        </para>
        <para>
            A forráskód alapján:
        </para>
        <para>
            b = 0011 ^ 0111 = 0100
        </para>
        <para>
            a = 0011 ^ 0100 = 0111
        </para>
        <para>
            b = 0111 ^ 0100 = 0011
        </para>
        <para>Látjuk, hogy az értékek felcserélődtek</para>
        <para>
            Segédváltozót felhasználva egyértelmű a csere. Egyik változó értéke elmentődik benne, megkapja ezek után a másik változó értékét és végül a másik változó az elmentett értéket.
        </para>
        <para>
            Összeadásos/kivonásos módszert szerintem nem kell magyarázni.
        </para>
        <para>
            a = 1; b = 6; b = b-a = 5;
            a = 1 + 5 = 6;
            b = 6 - 5 = 1;
        </para>
    </section>                     

    <section>
        <title>Labdapattogás</title>
        <para>
            Először if-ekkel, majd bármiféle logikai utasítás vagy kifejezés
            nasználata nélkül írj egy olyan programot, ami egy labdát pattogtat a karakteres konzolon! (Hogy mit értek
            pattogtatás alatt, alább láthatod a videókon.)
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/08/28/labdapattogas">https://bhaxor.blog.hu/2018/08/28/labdapattogas</link>
        </para>
        <para>
            Megoldás forrása:  
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
        <para>FIGYELEM!!!</para>
        <para>
            Megoldásom kipróbálásához, 
            fordításához szükséges az <application>ncurses</application> megléte.
            A legtöbb modern Linux disztró jön a megfelelő csomagokkal, 
            de például Ubuntu esetében szükséges lehet a <application>ncurses-dev</application> csomag telepítése.
        </para>
        <para>
            Fordítás:
        </para>
        <para>
            <command>gcc -o bouncingBall bouncingBall.c -lncurses</command>
        </para>
        <para>
            <command>
                gcc -o bouncingSets bouncingBallWithSets.c -lncurses
            </command>
        </para>
        <para>
            Elágazásokkal, főleg ha valaki már rajzolgatott program segítségével ablakokra/terminálba, 
            nagyon gyors a megoldás, 
            hiszen csak a labda pozícióját kell ellenőrizgetnünk, hogy érinti-e "börtönének" falait, 
            és ütközésnél a megfelőlen kell reagálnunk.
        </para>
        <para>
            Egy megvalósítását ennek alább láthatjuk:
        </para>
        <programlisting language="c">
            <![CDATA[
#include <ncurses.h>
#include <stdlib.h>
#include <unistd.h>

#define SLEEPY_TIME 60000

typedef struct ball
{
    int x, y, stepX, stepY;
    char ballBody;
} Ball;

void initializeWindow(char,char,int);
void destroyWindow();

Ball* createBall(char, int, int);
void update(Ball* theBall);


int winHeight, winWidth;

int main()
{
    
    initializeWindow(0,0,0);
    getmaxyx(stdscr,winWidth,winHeight);
    
    char key;
    
    Ball* theBall = createBall('O',10,12);
    
    while((key = getch()) == ERR)
    {
       
        update(theBall);
        usleep(SLEEPY_TIME); //unistd.h
        refresh();
    }
    
    
    destroyWindow();
    
    
    free(theBall);
    return 0;
}

void initializeWindow(char side_sym, char tops_sym, int cur_mod)
{
    initscr();
    cbreak();
    noecho();
    
    nodelay(stdscr, TRUE);
    curs_set(cur_mod);
  
    box(stdscr, side_sym,tops_sym);
}
void destroyWindow()
{
    getch();
    endwin();
}
Ball* createBall(char body, int posX, int posY)
{
    if((posX < 0 || posX > winHeight) || (posY < 0 || posY > winWidth))
    {
        mvprintw(0,0, "NEGATÍV vagy ABLAKON KÍVÜLI pozíciók lettek megadva!");
        destroyWindow();
        exit(-1);
    }
    
    Ball* theBall = (Ball*)calloc(1,sizeof(Ball));    
    theBall->ballBody = body;
    (posX >= 2 && posX < winWidth - 3) ? theBall->x = posX : 2;
    (posY >= 2 && posY < winHeight - 3) ? theBall->y = posY : 2;
    theBall->stepX = 1;
    theBall->stepY = 1;
    
    return theBall;
}
void update(Ball* theBall)
{
    if((theBall->x < 2) || (theBall->x > winWidth-3))
    {    theBall->stepX*=-1;}
    if((theBall->y < 2) || (theBall->y > winHeight-3))
    {    theBall->stepY*=-1;}
    
    mvaddch(theBall->x, theBall->y, ' ' | A_NORMAL);
    
    theBall->x += theBall->stepX;
    theBall->y += theBall->stepY;
    
    mvaddch(theBall->x, theBall->y, theBall->ballBody );
}
            ]]>
        </programlisting>
        <para>
            Aki nem tudná az <application>ncurses</application> könyvtár a pseudo-/terminal alkalmazásokban
            enged GUI-kat (TUI épül ki pontosabban) építeni, rajzolni, illetve engedi kihasználni az adott terminál képességeit könnyedén.
            Például: kurzor mozgatása, színezés, input handling, ...
        </para>
        <para>
            Program működéséről röviden:
        </para>
        <para>
            <application>ncurses</application> könyvtár segítségével felépül a környezet, inicializáljuk a módot,
            beállítjuk, hogy a bemenet egyből a programhoz kerüljön, s ne kelljen '\n'-t beütnünk, kurzurt kikapcsoljuk,...
            Működését nem tárgyalnám, további információk : 
        </para>
        <para>
            <link xlink:href="http://tldp.org/HOWTO/NCURSES-Programming-HOWTO/">
                    <filename>NCURSES - HOW TO</filename>
            </link>
        </para>
        <para>
            A labda szerkezetét egy Ball nevű struct-ban tároljuk, létrehozásáról a <function>createBall</function> nevű függvény gondoskodik,
            ami egy mutatóval tér vissza a heap-en elhelyezkedő labdáról. Ugyanitt leellenőrizzük, hogy a labda paramétereit helyesen adta-e meg a user(programozó), tehát benne van-e a "világában" a labda.
            
        </para>
        <para>
            Eztuán belépünk a render ciklusba, ami addig iterálja a <function>update</function> 
            <function>usleep</function> 
            <function>refresh</function> függvényeket, amíg le nem nyomunk egy gombot. Ez ugye az <application>ncurses</application> felhasználásával valósul meg.
            Kivétel az <function>update</function> függvény, ami user-defined, tehát én írtam, illetve az <function>usleep</function> függvény amit az <application>unistd.h</application> biztosít, vele várakozunk/lassítjuk a labda mozgását(iterálást).
        </para>
        <para>
            Az <function>update</function> folyamatosan mozgatja a labdát, ellenőrzi, hogy ne menjen át a határokon, illetve meghívja az <function>mvaddch</function> 
            <application>ncurses</application> függvényt, ami kirajzolja őt a megfelelő helyre(pozícíójára).
        </para>
        <para>
            A ciklus megszakítását követően pedig felszabadítjuk a labdánkat heap-en található börtönéből.
        </para>
        <para>
            Létezik erre egy másik megoldás is, azaz az elágazás nélküli "pattogtatás".
        </para>
        <para>
            A lényege ennek a megoldásnak az, hogy két számsort tartunk számon(mindkét "tengelynek", az egyik csökken, másik nő, és csak a határokon belüli értékeket vesznek fel.
            Ha csak egy-egy számsort tartanánk fenn akkor hirtelen lenne egy ugrás a max értékről a 0-ra, vagy fordítva. 
            A határon nem átkelésről a % operátor gondoskodik, ami maradékos osztást visz véghez, azaz mindig 0-(határ-1) értékkel fogunk dolgozni.
        </para>
        <para>
            Ezután összemossuk a megfelelő számsorokat, így kapja egy új hullámzó számsort, ami leírja a labda pályájának megfelelő x/y pozícióit.
            Megfigyelhetjük azt is, hogy duplán vesszük a konzolunk méreteit. Ez egyfajta lassításnak felel meg, ugyanis ha az eredeti méreteivel dolgoznánk, ugrálna labda, így pedig minden lépés 1 egység.
        </para>
        <para>
            Az <application>ncurses</application> működéséről nem beszélnék részletesen, lásd link fentebb.
        </para>
        <programlisting language="c">
            <![CDATA[
                 #include <ncurses.h>
#include <stdlib.h>
#include <unistd.h>

#define SLEEPY_TIME 60000

typedef struct ball
{
    int x, y;
    char ballBody;
} Ball;

void initializeWindow(char,char,int);
void destroyWindow();

void update(Ball* theBall);


int winHeight, winWidth;
int helperX=0, helperY=0;

int main()
{
    
    initializeWindow(0,0,0);
    getmaxyx(stdscr,winWidth,winHeight);
    
    winWidth*=2;
    winHeight*=2;
    
    
    Ball theBall = {0, 0, 'o'};
    
    for(;;)
    {
       
        update(&theBall);
        usleep(SLEEPY_TIME);
        refresh();
    }
    
    
    destroyWindow();
    
    
    return 0;
}

void initializeWindow(char side_sym, char tops_sym, int cur_mod)
{
    initscr();
    cbreak();
    noecho();
    
    nodelay(stdscr, TRUE);
    curs_set(cur_mod);
  
    box(stdscr, side_sym,tops_sym);
}
void destroyWindow()
{
    getch();
    endwin();
}

void update(Ball* theBall)
{
    mvaddch(abs(theBall->y + (winWidth-helperY))/2,abs(theBall->x + (winHeight-helperX))/2 , ' ');
    theBall->x = (theBall->x-1) % winHeight;
    helperX =  (helperX+1) % winHeight;
    
    theBall->y = (theBall->y-1) % winWidth;
    helperY = (helperY+1) % winWidth;
    
    mvaddch(abs(theBall->y + (winWidth-helperY))/2,abs(theBall->x + (winHeight-helperX))/2 , theBall->ballBody);
    
    box(stdscr, 0,0); // this is a hack, very simple hack, heck
}
            ]]>
        </programlisting>
    </section>                     

    <section>
        <title>Szóhossz és a Linus Torvalds féle BogoMIPS</title>
        <para>
            Írj egy programot, ami megnézi, hogy hány bites a szó a gépeden, azaz mekkora az <type>int</type> mérete.
            Használd ugyanazt a while ciklus fejet, amit Linus Torvalds a BogoMIPS rutinjában! 
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat... 
        </para>
    </section>                     

    <section>
        <title>Helló, Google!</title>
        <para>
            Írj olyan C programot, amely egy 4 honlapból álló hálózatra kiszámolja a négy lap Page-Rank 
            értékét!
        </para>
        <para>
            Megoldás videó: <link xlink:href=""></link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

    <section xml:id="Brun">
        <title>100 éves a Brun tétel</title>
        <para>
            Írj R szimulációt a Brun tétel demonstrálására!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://youtu.be/xbYhp9G6VqQ">https://youtu.be/xbYhp9G6VqQ</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R">https://gitlab.com/nbatfai/bhax/blob/master/attention_raising/Primek_R</link>
        </para>
    </section>
    
    <section xml:id="bhax-textbook-feladatok-turing.MontyHall">
        <title>A Monty Hall probléma</title>
        <para>
            Írj R szimulációt a Monty Hall problémára!
        </para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan">https://bhaxor.blog.hu/2019/01/03/erdos_pal_mit_keresett_a_nagykonyvben_a_monty_hall-paradoxon_kapcsan</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href="https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R">https://gitlab.com/nbatfai/bhax/tree/master/attention_raising/MontyHall_R</link>
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>
    </section>

</chapter>                

</chapter>                
