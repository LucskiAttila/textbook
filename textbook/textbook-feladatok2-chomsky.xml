<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Chomsky!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Encoding</title>
     <para>
	Fordítsuk le és futtassuk a Javat tanítok könyv MandelbrotHalmazNagyító.java forrását úgy, hogy a fájl nevekben és a forrásokban is meghagyjuk az ékezetes betűket! https://www.tankonyvtar.hu/hu/tartalom/tkt/javat-tanitok-javat/adatok.html     
     </para>
	<para>
    Virtualbox-szal használok Ubuntu 18.04.3 LTS verzióju operációs rendszert és forditási hiba nélkül lefordul, ha letöltöm és forditom előtte MandelbrotHalmazNagyító néven a MandelbrotHalmazNagyító.java fájlt. Ugye a Java objektum-orientált nyelv igy az egész program egy osztályban van és annak az osztálynak a nevével kell elnevezni a fájlt is amibe van. 
    Windows alatt a fordítás sikeres mivel felismeri a kód karakterkészletét automatikusan. Ubuntu alatt azonban hibát kapunk mivel alapértelmezetten UTF-8 karakterkódolást használ, melynek nem része a magyar nyelv, mivel nem tartalmazza az ékezetes betűket. A magyar ékezetes betűk helyes megjelenítéséhez az encoding kapcsolót kell használnunk fordításkor, mivel ennek seg1tségével megadhatjuk több választék közül hogy melyik karakterkódolást használja a fordító, ami ugye alpértelmezetten az UTF-8-ban és ezt módosítjuk az encoding opcióval windows-1250 karakterkódolásra, amit az Észak-Európa-i nyelvek számára készítettek, ami illik Magyarországon használt ékezetes betűs nyelvre.
    Windows alatt a linket másolva a pdf-ből Microsoft Edge böngészővel 404-es hibakódú hibát kapunk mivel rossz link illesztődik be a böngésző címsorába: https://www.tankonyvtar.hu/hu/tartalom/tkt/javattanitok%20javat/adatok.html. Így átkell javítani a pdf alapján.
	</para>  
	   <mediaobject>
            <imageobject>
                <imagedata fileref=".png"></imagedata>
            </imageobject>
        </mediaobject>
     </section>
	
     <section>
	     <title>OOCWC lexer</title>
	     <para>
		  Izzítsuk be az OOCWC-t és vázoljuk a https://github.com/nbatfai/robocaremulator/blob/master/justine/rcemu/src/carlexer.ll lexert és kapcsolását a programunk OO struktúrájába!   
	     </para>
	     <para>
	A Robocar Világbajnokság (OOCWC) célja egy közös kutatási platform létrehozása a városi forgalomirányítási algoritmusok kidolgozására, valamint az intelligens városok és a robotautók kapcsolatának vizsgálatára, különös figyelmet fordítva a közeljövőben működő robotautók terjedésére.
	Ahogy a carlexexer.ll fájl nevéből és kiterjesztéséből láthatjuk a programot lexer segítségével használjuk, ami egy lexikai elemzőt generáló program. Pontosabban először beolvassa a bemenetet, majd tokenizálja, lexálja azt, majd generálja az elemzőt C++ nyelven. Lexálás alatt azt értjük hogy egy karaktersorozatot token sorzattá alakítunk át, ehhez a tokeneknek egy név és érték mezőből kell állniuk, melyek segítségével a konvertálás végrehajtódhat. 
	A lexer program felépítése a következő: 
		     {definíciók}
		     %%
		     {szabályok}
		     %%
		     {felhasználói utasítások}
	A CarLexer a FlexLexer alosztálya: figyeli, hogy az egyének milyen úton vannak, illetve hogy egy jármű kísérve van-e. A carlexer.hpp fájlt is includoltuk hogy a benne lévő globális változók értékeit módosíthassuk a programunk segítségével.
	A definíciók részben hozzuk létr a lexáláshoz szükséges tokeneket, melynek megadjuk a nevét amivel azonosítjuk majd a felhasználói utasítások részben, illetve egy sztringet amiből a beolvasott szöveg fog állni. Ahogy például a STAT esetén a <stat sztringet olvassuk be. A WS esetén a /t a whitespacet jelenti, a csillag ugye hogy akárhányszor szerepelhet, akár 0-szor is a + jelöléssel ellentétben ugye. A WORLD esetén a ^ jelölés azt jelenti hogy a mögötte felsorolt karaktereken kívül bármi lehet, a {} pedig hogy a kapcsos zárójel közötti elemből áll a beolvasott karaktersorozat.	     
	A szabályok részben megadjuk hogy az általunk képzett reguláris kifejezések illeszkedése esetén mikre módosuljanak a változók értékei. 
	A felhasználói utasítások részben definiáljuk az yylex függvényt, ami ugye beolvassa a bemenetet az egyes CarLExer objektumokra.
        A lex parancs segítségével hatjsuk végre a lexálást az adott forráskód alapján, ami jelen esetben a carlexer.ll: 
	      </para>
	           <programlisting language = "C++">

          <![CDATA[ 
	     %option c++
%option noyywrap

%{
#define YY_DECL int justine::robocar::CarLexer::yylex()
#include "carlexer.hpp"
#include <cstdio>
#include <limits>
%}

INIT	"<init"
INITG	"<init guided"
WS	[ \t]*
WORD	[^-:\n \t()]{2,}
INT	[0123456789]+
FLOAT	[-.0123456789]+
ROUTE	"<route"
CAR	"<car"
POS	"<pos"
GANGSTERS	"<gangsters"
STAT	"<stat"
DISP	"<disp>"
%% 
{DISP}					{
					  m_cmd = 0;
					}
{POS}{WS}{INT}{WS}{INT}{WS}{INT}	{
					  std::sscanf(yytext, "<pos %d %u %u", &m_id, &from, &to);
					  m_cmd = 10001;
					}
{CAR}{WS}{INT}				{
					  std::sscanf(yytext, "<car %d", &m_id);
					  m_cmd = 1001;
					}
{STAT}{WS}{INT}				{
					  std::sscanf(yytext, "<stat %d", &m_id);
					  m_cmd = 1003;
					}
{GANGSTERS}{WS}{INT}			{
					  std::sscanf(yytext, "<gangsters %d", &m_id);
					  m_cmd = 1002;
					}
{ROUTE}{WS}{INT}{WS}{INT}({WS}{INT})*	{
				  int size{0};
				  int ss{0};
				  int sn{0};				  
				  
				  std::sscanf(yytext, "<route %d %d%n", &size, &m_id, &sn);
				  ss += sn;
				  for(int i{0}; i<size; ++i)
				  {
				    unsigned int u{0u};
				    std::sscanf(yytext+ss, "%u%n", &u, &sn);
				    route.push_back(u);
				    ss += sn; 				    
				  }
				  m_cmd = 101;
				}
{INIT}{WS}{WORD}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init %s %c>", name, &role);
				  num = 1;
				  m_cmd = 0;
				}
{INIT}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init %s %d %c>", name, &num, &role);
				  if(num >200)
				  {
				    m_errnumber = 1;
				    num = 200;
				  }
				  m_cmd = 1;
				}				
{INITG}{WS}{WORD}{WS}("c"|"g")	{
				  std::sscanf(yytext, "<init guided %s %c>", name, &role);
				  num = 1;
				  m_guided = true;
				  m_cmd = 3;
				}
{INITG}{WS}{WORD}{WS}{INT}{WS}("c"|"g")	{				  
				  std::sscanf(yytext, "<init guided %s %d %c>", name, &num, &role);
				  if(num >200)
				  {
				    m_errnumber = 1;
				    num = 200;
				  }
				  m_guided = true;
				  m_cmd = 2;
				}								
.				{;}
%%

int yyFlexLexer::yylex(){return -1;}            
           ]]>

        </programlisting>
	<mediaobject>
            <imageobject>
                <imagedata fileref=".png"></imagedata>
            </imageobject>
        </mediaobject>
	</section>
	
	<section>
    <title>l334d1c45</title>
        <para>
	Írj olyan OO Java vagy C++ osztályt, amely leet cipherként működik, azaz megvalósítja ezt a betű helyettesítést: https://simple.wikipedia.org/wiki/Leet (Ha ez első részben nem tetted meg, akkor írasd ki és magyarázd meg a használt struktúratömb memóriafoglalását!)	
	</para>
 <para>
      A l33t nyelvről már volt szó korábban, most Javaban ismét elővesszük és OO, azaz objektum-orientált környezetben is dolgozunk vele egy kicsit. Ha már elfelejtettük volna akkor, a leet nyelv egy internetes nyelv vagy ábécé amely különböző ASCII karakterekre cseréli a hagyományos Latin betűket. Maga a szó az elite, azaz az elit szóból ered, amely vonatkozhatott arra, hogy aki megérti ezt a cifra nyelvet az az internet elitjébe tartozott. 
      Kicsit egyszerűsítve, az ábécé poolokat és a randomizálást kihagyva, most egy betűnek csak egy leet megfelelője lesz. A program egy text inputot kér a felhasználótól, aminek minden karakterét sorra nézi és az annak megfelelő leet karaktert egy stringbuilde hozzáfűzi a l33t szóhoz.
  
	A struktúratömb mértetének vizsgálatához a l337d1c7.l fájlból az alábbi struktúra szükséges:
	struct chiper {
		char c;
	 	char* leet[4]; }
	Az osztályból létrejövő objektumok mértetét meghatározhatjuk egy egyszerű számítással ógy hogy tudjuk hogy egy char típus 1 bájtot foglal, a char* pedit 8 bájtot, de ebből 4 van így a képletünk 1+4*8 ami 33 bájt lenne. Ha viszont a size függvénnyel határozzuk meg a tényleges méretet érdekes módon nem 33-at kapunk, hanem 40-et. Erre a magyarázat a padding jelenség, amit a fordító automatikusan végez. A padding azt jelenti hogy ha a egy struktúra elem előtt vagy mögött van egy nagyobb méretű elem akkor a kisebb méretű elem mérete módosul a nagyobbéra. Ezt a plusz tárhelyfoglálsi módszert a címzésből adódó hibák elkerülése végett találták ki. Így jön ki a 40 bájt mivel a char memóriamérete 8 bájtra módosult. A paddingot kikapcsolhatjuk a #pragma pack(1) macro segítségével, így a várt 33 bájt méretet kapjuk.                               		
		
		
</para>

<programlisting language = "Java">
          <![CDATA[ 
          
          import java.util.Scanner;



public class Leet {

    private static StringBuilder transform(String input, StringBuilder sb)
    {

        input=input.toUpperCase();
        for(int i=0;i<input.length();i++)
        {
            switch (input.charAt(i)) {
                case 'A' : sb.append("4");
                    break;
                case 'B' : sb.append("|3");
                    break;
                case 'C' : sb.append("(");
                    break;
                case 'D' : sb.append("|)");
                    break;
                case 'E' : sb.append("3");
                    break;
                case 'F' : sb.append("|=");
                    break;
                case 'G' : sb.append("6");
                    break;
                case 'H' : sb.append("|-|");
                    break;
                case 'I' : sb.append("|");
                    break;
                case 'J' : sb.append(".]");
                    break;
                case 'K' : sb.append("|<");
                    break;
                case 'L' : sb.append("1");
                    break;
                case 'M' : sb.append("|Y|");
                    break;
                case 'N' : sb.append("/V");
                    break;
                case 'O' : sb.append("Ø");
                    break;
                case 'P' : sb.append("|O");
                    break;
                case 'Q' : sb.append("(,)");
                    break;
                case 'R' : sb.append("®");
                    break;
                case 'S' : sb.append("§");
                    break;
                case 'T' : sb.append("7");
                    break;
                case 'U' : sb.append("|_|");
                    break;
                case 'V' : sb.append("V");
                    break;
                case 'W' : sb.append("\\^/");
                    break;
                case 'X' : sb.append(" }{");
                    break;
                case 'Y' : sb.append("¥");
                    break;
                case 'Z' : sb.append("2");
                    break;
                case ' ' : sb.append(" ");
                    break;
                    default: sb.append(input.charAt(i));
            }


        }

        return sb;
    }

    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        Scanner scan = new Scanner(System.in);
        String input;

        System.out.println("Please enter the text that you want to l33tify");
        input=scan.nextLine();
        System.out.println("The 1337 version of your input is: \n");

        sb=transform(input,sb);

        System.out.print(sb);
        System.out.println("\n");

        }

    }
          ]]>
        </programlisting>
     
		
		
 
      
