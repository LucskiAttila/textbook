<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Gutenberg!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Juhász István - Magas szintű programozási nyelvek 1; olvasónapló</title>
      
        <para>
	   A szamitogepes nyelveknek megkulonboztetjuk a szintjeit, leteznek gepi nyelvek es magas szintu nyelvek. Minden processzornak van egy gepi nyelve, melyen vegrehajtja az utasitsaokat, azonban az altalunk irt magasszintu nyelveken irt kodon irt utasitasokat a processzor nem tudja vegrehajtani mivel nem gepi nyelven van irva, igy at kell alakitanunk gepi nyelvve. A magasszintu nyelvek peldaul a C, melyek sajat szintaktikai esz szemantikai tulajdonsagokkal rendelkeznek. A magasszintu nyevlek gepi nyelvekke alakitasara ket modszer van az egyik a forditoprogramos a masik az interpretes. A forditoprogramos atalikitast hasznaljuk mivel ellenorzi a kodot szintaktikailag es szematikailag mielott leforditana, ilyen peldaul a C nyelvhez a gcc, melynek tobb valtozoata ismert c90, c11, melyeknek neveiben az evjaratra utalnak a szamjegyek. A forditoprogram keszit targyprogramot, ha szintaktialag helyes a kodunk, melyet a gcc forditonal az -o kapcsoloval nevezhetunk el. Az interpretes forditassal a kod rogton lefut az ellenorzesek utan, mivel nem keszul targyprogram amit kesobb is futtathatunk. A programozasi nyelveket ket fobb osztalyba sorolhatjuk az egyik az inperativ nyelvek, melyekbe algoritmusok segitsegevel irjuk meg az utasitasokat kulonbozo valtozokat felhasznalva es van lehetosegunk memoriafoglalasra is, ezeket gyakroabban hasznaljuk ilyen peldaul a C nyelv. Vannak a deklarativ nyelvek amelyek nagyabol az inperativ nyelvekkel ellenkezo tulajdonsagokkal rendelkeznek, presze ezeken kivul leteznek meg maselvu nyelvek amelyek nincs egyseges jellemzojuk. Minden programnyelvnek sajat karakterkeszlete van mely betukbol, szamokbol es egyeb karakterekbol epul fel. A szamok altalaban egyseges decimalis szamok. A betuknel eltero lehet hogy kulon kezeli e a kis es nagybetuket mint peldaul a C nyelv. A specialis karakterek kozul a szokozt, tabulatort, entert nem kulonbozteti meg a fordito, ezeket egysegesen white space-knek nevezzuk, tehat mindegy melyiket hasznaljuk szo alkotasra szintaktikai szempontbol, azonban a jobb atlathatosag miatt hasznaljuk mindegyiket. A forrasprogramban elofordulo lexikalis egysegeket a lexikalis elemzes soran a fordito felismeri es tokenizalja azokat, ilyenek a tobbkarakteres szinbolumok peldaul C nyevlben a ++, a szimbolikus nevek amiket a programozo hoz letre az egyes elemek azonositasara, ezeknek a neveinek betu karakterekkel kell kezdodniuk es nem tartalmazhatnak speacialis karaktereket peldaul muveleti jeleket es a kulcsszok peldaul az if melynek a nyelv tulajdonit jelentest, megjegyzesek melyek segitik a program ertelmezest az olvaso szamara, a cimkek melyekkel a cimkezett utasitasra a program egy masik reszebol hivatkozni tudunk, literalok melyek megadjak a valtozo tipusat peldaul a double. Vannak kotott es szabad formatu nyelvek, a kotott formatumu nyelvekben egy sor egy utasitas ha nem fert ki egy sorba kulon jelezni kellett a sorvege torlesevel es a programelemeknek is meghatarozott helye van a sorban. A szabad formatumu elemeknel egy sorban akarhany utasitas kerulhet es tetszoleges poziciokban hasznalhatjuk a programelemeket, az utasitasok veget pedig pontosveeszovel jelezzuk. Az eljarasorientalt nyelvekbn a lexikalis egysegeket a megfelelo modon el kell valasztanunk egymastol whitespace-szel vagy elhatarolo jelekkel peldaul zarojellel. A kifejezesek segitsegevel egy adott ertekbol, operandusbol uj erteket hatarozunk meg operatorok segitsegevel, ehhez hasznalhatunk zarojelezest is hogy meghatarozzuk a muveleti sorrendet. A ketoperandusu kifejezesk alakjait az operator elhelyezkedese hatarozza meg, ha elol van akkor prefix alaku, ha kozepen infix, ha az operandusok mogott akkor postfix. A muveletek megfelelo sorrendbeli vegrehajtasa utan a kifejezesnek megkapjuk az uj erteket es hozzarendelodik a tipusa, ezt a kifejezes kiertekelesenek nevezzuk. A muveletek vegrehajtasi sorrendje lehet balrol-jobbra, jobbrol-balra, balrol-jobbra a precedenciatablazat segitsegevel. Mivel az infix alak operatorai nem azonos erosseguek igy az infix alak nem egyertelmu, ehhez hasznaljuk a precedenciatalbazatot, melynek muveleti sorrendjet felulirhatjuk zarojelek hasznalataval, a teljesen bezarojelezett alaknak egy muveletvegrehajtasi sorrednje van. A kifejezes tipusanak meghatarozasara ketfele modszer van, az egyik a tipusegyenloseg ekkor a ketoperandusu kifejezes mindeket erteke azonostipusu vagy az operator hatarozza meg a tipust. Ket programozasi eszkoz tipusa akkor azonos ha egy utasitasban dekralaltuk es azonos tipussal es a ket eszkoz osszetett tipusu, szerkezetuk megegyezik. A tipuskenyszerites moszerevel a ketoperandusu kifejezeseknek kulonbozo tipusu operandusai lehetnek, a muveletek viszont csak azonos tipusu operandusokkal vegezhetoek el igy annak megfeleloen atkonvertalodnak. A tipuskenyszeritesnek van boviteses fajtaja amikor a konvertalando tipus elemei elemei a celtipusnak is, szukites eseten viszont nem elemei es ekkor ertekcsonkitas vagy kerekites tortenik. Az utasitasok alkotjak az algoritmusok egyes reszeit, illetve a forditoprogram ennek segitsegevel generalja le a targyprogramot, ezek alapjan ket csoportjuk van dekralacios es vegrehajto utasitasok. A deklaracios utasitasok informaciot szolgaltat a targykod generalasahoz, a vegrehajto utasitasokat pedig leforditja targykodra. A vegrehajto utasitasokat kilenc csoportba sorolhatjuk. Az ertekado utasitas segitsegevel erteket adhatunk valtozoknak a program futasa alatt. Az ures utasitas segitesegevel a program egy ures gepi utasitast hajt vegre, ez szintaktikailag hasznos. Az ugro utasitas segitsegevel egy adott cimkevel ellatott utasitasnak adhatjuk at a vezerlest a GOTO parancs segitsegevel. Az elagaztato utasitas segitsegevel a program tobb tevekenyseg kozul hasznalja a megfelelot. A ciklusvezerlo utasitas segitsegevel a porgram egy adott tevekenyseget tobbszor is vegrehajthat, akar vegtelenszer is. C nyelvben a CONTINOU utasitas az aktualis ciklusszalbol kilep nem hatja vegre a tovabbi utasitast, hanem ujabb szalba kezd.

	</para>
    </section>        
    
    <section>
        <title>Kerninghan és Richie; olvasónapló</title>
        
        <para>
	A vegrehajtando muveletek sorrendjet a vezerlesatado utasitasok adjak meg. A kifejezesek vegere pontosvesszot teszunk hogy utasitaskent mukodjenek, egyebkent forditaskor szintaktikai hibat kapnank. Osszetettt utasitasokat letrehozhatunk, ha kapcsos zarojelek koze adunk meg tobb utasitast, ezek vegere nem kell pontosvesszo. Az if-else utasitas a parameterkent kapott kifejezes erteke alapjan donti el hogy vegrehajtja e a hozzarendelt utasitast, ha egy az erteke akkor vegrehajtja, nulla ertek eseten viszont nem hatja vegre, hanem ha adunk meg else agat annak az utasitasat hajtja vegre. Az if illetve az else vegrehajtja az utannauk kovetkezo utasitast vagy utasitasokat amit ugye kapcsoszarojelben kell megadnunk. Az if utasitasokat egymasba is agyazhatjuk egymasbol kovetkezo feltelek eseten, kapcsoszarojel hasznalata nelkul az else mindig a hozza legkozelebb esso if-hez tartozik. A kapcsos zarojel hasznalataval a beagyazott if utasitasok eseten az esle ag melyik if utasitashoz tartozasat is meghatarozhatjuk. Egy if utasitashoz egy else ag tartozhat ami hatekonyabban mukodik mint ket if utasitas hasznalata. Az else-if utasitasokban megadunk egy kezdo if utasitast majd akarhany elseif utasitast megadhatunk melyek egymas utan kiertekelodnek es ha az egyik erteke egy akkor vegrehajtja a hozzarendelt utasitast es kilep az else-if utasitasbol. Ha az if es minden else-if ag erteke nulla akkor ha van else ag akkor az ahhoz rendelt utasitas hajtodik vegre, ezt hasznaljuk hibakezeleskent is. A switch utasitast parameterekent megadunk egy kifejezest majd egy osszetett utasitasban megadjunk akarhany case ` ` : agat majd egy default: agat. A case ` ` reszeben megadunk egy allando erteku kifejezest melynek erteke ha megegyezik a switch parameterekent adott ertekkel akkor vegrehajtja a case : utan megadott utasitast. Ha egyetelen case eseteben megadott kifejezes erteke sem egyezik meg a switch parameterkent adott ertekevel akkor a default aghoz rendelt utasitas hajtodik vegre. A while utasitas a parameterekent megadott kifejezes erteket ellenorzi hogy egy e, ha igen akkor vegrehatja a hozzarendelt utasitast, majd ismet ellenorzi es egy ertek eseten ujra vegrehatja az utasitast, majd ezt addig hajtja vegre rekurzivan amig a kifejezes erteke nem lesz nulla. Ha a parameterkent adott kifejezes erteke egy akkor vegtelenszer hajtja vegre a while a hozzarendelt utasitast. Ha a prameterkent adott kifejezes tartalmaz valtozot, annak erteket modositjak a while utasitashoz rendelt utasitasok. A for utasitasnak harom kifezest adhatunk meg parameterul, melyek kozul az elso kezdoerteket ad a masdoik kifejezesben vizsgalt operandusnak, a masodik kifejezes operator segitsegevel eldonti nem nulla vagy nulla az aktualis erteke a kifejezenek, a harmadik kifejezzel pedig modsitjuk az elso parameterkent megadott valtozo erteket. A kifejezesek elhagyasaval es a harom pontosvesszo hasznalataval vegtelenszer fogja vegrehajtani a for utasitas a hozzarendelt utasitast. Minden for utasitast atirhatunk while utasitassa ugy hogy a for ciklus parameterekent megadott elso kifejezest a while ciklus elott definialjuk, a masodik kifejezes a while utasitas parametere lesz, a harmadik kifejezest pedig a while utasitashoz rendelt utasitasban definialjuk. A do-while utasitas a do utasitashoz rendelt utasitast hajtja vegre majd ellenorzi a while utasitas parametereul adott kifejezes erteket hogy nulla e ,ha nem ujra vegrehajtja a do utasitashoz rendelt utasitast majd ismet ellenorzi a while utasitas parametereul adott kifejezes erteket hogy nulla e, ezt hajtja vegre rekurzivan amig a while utasitas parametereul adott kifejezes erteke nulla nem lesz. A for es a while utasitassal ellentetben nem az utasitas vegrehajtasa elott ellenorzi hogy vegrehajtja e vagy nem, hanem eloszor vegrehajtja az utasitast majd ellenorzi hogy vegrehajtja e ujbol. A while ciklushoz hasonloan itt is az utasitas reszben valtozhat a valtozo erteke, amit operanduskent hasznal a while utasitas parameterekent megadott kifejezes. A do utasitashoz rendelt utasitast celszeru kapcsoszarojelben hasznalni hogy biztosan a while utasitashoz tartozzon. A break utasitas segitsegevel kilep a for, while, do-while, switch utasitasokbol a lefordulasakor, tehat nem addig hajtodik vegre amig a kifejezes erteke nulla nem lesz hanem addig amig a break utasitas le nem fordul. A countinu utasitas a for, while, do-while utasitasokhoz tartozo utasitasbol kilep es ismet a parameterkent adott kifejezes vagy kifejezesek erteke alapjan donti el hogy ujra lefut e az ugye for vagy while utasitashoz rendelt utasitas. Tehat a for es a while utasitasokhoz rendelt utasitasoknak az utasitasai a countinou utasitas lefutasaig hajtodnak vegre, nem a teljes utasitas utolso utasitasaig. A goto utasitast a tobbszorosen egymasba agyazott utasitasokbol valo kilepesre hasznaljuk ugy hogy az adott utasitasban megadott goto cimke nevu utasitas vegrehajtodasakor a cimke nevu cimkehez tartozo utasitasra ugrik a program. Cimket a cimkeneve : utasitas paranccsal hozhatunk letre. A goto utasitas hasznalataval csak az adott fuggvenyben cimkezett utasitas erheto el. A goto hasznalata kikerulheto megfelelo seged utasitasok hasznalataval. 
	</para>
    </section>        
    <section>
        <title> BME: Szoftverfejlesztés C++ nyelven / Benedek Zoltán, Levendovszky Tihamér ; olvasónapló</title>
        
        <para>
	A konyvtarakban van definialva a hiba, melyeket megfeleloen kezelhetunk, az ilyen definialt hibakat kiveteleknek azaz exeption-nak nevezzuk. A kivetelkezesles ugy tortenik hogyha egy fuggveny nem tud kezelni egy hibat kivetelt dob ra a throw fuggvennyel melyet a catch fuggvennyel elkaphatunk ha megfelelo kivetelt definialtunk. Hibakezelesnel nelkul a program hiba eseten leall vagy hibasan mukodik. A C++ programoknak az alapveto hibakezelese hogy hiba eseten a program leall, kiveve ha a el nem kapjuk az osszes hibat es megfeleloen kezeljuk hogy ne alljon le. A  C programoknal viszont tovabb fut hibasan is, es igy csak kesobb derulhet ki a hiba esetleges leallas eseten. A kivetelkezeles a szinkron kivetelek kezelesere szolgal pedlaul a ki es bemeneti hibak, az aszinkron esemenyeket pedlaul a billentyuzet felol erkezo hibat szignalokkal kezeljuk. A kivetel elofordulast egy osztallyal irjuk le melynek egy objektuma a kivetel. Van ugynevezett vegrehajtasi verem mely a throw fuggveny meghivasaval tekerodik vissza a catch fuggvenyig. A kivetelek osztalyait hierarikusan kezeljuk hogy egyszerubben tudjuk modositani azokat. A kivetelket csak akkor tudjuk elkapni ha a catch parameterenek tipusa megegyezik a throw-val meghivottnak, vagy ha a catch parametere foosztalya a throw-val meghivottnak, vagy ha a catch parametere es a throw-ra meghivott is mutatotipus melyeknek vagy megegyezik a tipusuk vagy a catch parametere bazisosztalya a throw-val meghivottnak, vagy ha a catch parametere referencia es teljesul ra hogy megeyezik a tipusa a throw-val meghivotteval vagy bazisosztalya a throw-val meghivottnak. A const szo hasznalataval a kivetelek erteket nem valtoztathatjuk es minden kivetel masolhato. Ha nem tudjuk kezelni teljes egeszeben az elkapott kivetelt akkor tovabdobhatjuk a throw utasitas lefuttatasaval, ekkor nem az elkapott kivetelt dobjuk tovabb hanem az eredeti throw altal dobottat. A try fuggvenyben definialjuk a catch fuggvenyeket, melyeknek a sorrendje osztaly hierarhia szerint novekvo sorrendben kell legyen mivel ekkor az alosztalyok nem kapodnanak el. Fajlkezelesnel a megnyitott fajlt nem mindig zarul automatikusan, mivel ha a hiba az fclose meghivodasa elott van akkor a hibat kezelhetjuk a use_file() fuggveny visszateresi erteket ad a hibat felismero fuggvenynek, de az fclose fuggveny mar nem hivodik meg igy a lefoglalt memoriaelfolyik. Ezt a hibat javithatnank ugyis hogy a catch fuggvennyel elkapunk minden kivetelt es meghivjuk benne az fclose fuggvenyt, de ez nagyobb kodoknal bonyolultabb igy osztalyban definialjuk a fajlkezelest melynek a destruktora elvegzi a megfelelo memoriafelszabaditast a kivetelkezelestol fuggetelenul. A hasznalatos objektumokat lokalis objektumkent hozzuk letre a konstruktor inicializacios listajaval, mivel a konstruktor segitsegevel letrehozott objektumot torli a destruktor es az igy letrehozott objektum teljesen jon letre megfeleloen megirt konstruktor eseten. Az inicializaios lista hasznalataval a fordito ellenorzi hogy a letrehozott objektumok letrehozasa kozben kivetel adodik akkor csak a letrehozott objektum torlodik, igy nem szukseges a konstruktor irashoz kivetelkezelo kod. Ha csak egy objektum resz jon letre mivel kivetel van a konstruktor parameterben akkor nem jon letre teljesen az objektum igy a destruktor nem torli, ehelyett inicializasios lista segitsegevel vektort hasznalunk az objektum memoriakezelesehez. Az std konyvtarban van auto_ptr kisebbkacsacsor nagyobbkacsacsor sablon mely a kisebbkacsacsor nagyobbkacsacsor kozott megadott tipussal hoz letre mutatot az adott objektumra, hasonloan mukodik a hagyomanyos mutatokhoz, de torlesekor megsemmisul az altala mutatott objektum is. Az auot_ptr egy masik mutatoba masolasval a mutato nem mutat semmire es az auto_ptr-eket a masoolas megvaltoztatja, de hasznalhatjuk ra a const kulcsszot melynek segitsegevel nem lesz masolhato. Ezt az auto_ptr_ref akadalyozza meg es megvalositsa a masolasukat. Nem std tipusuokkal valo masolasa peldaul vektorba masolaskor serules veszely all fenn. Az auto_ptr altal mutatott objektum torlodik a kivetelkezeletol fuggetlenul. Elhelyezo utasitas hasznataval kivetelkezeleskor is felszabadul a new altal lefoglalt hely a megfelelo delete parancsokkal automatikusan, mas modon lefoglalt memoriarat nem szabadit fel automatikusan. Ha elfogy a memoria a memoriaszivargasok miatt akkor kivetelkezelessel es egy vegtelen ciklussal hasznalt malloc fuggveny segitsegevel kereshetunk memoriacimeket, melyeket a tulterhelt new fuggveny ad vissza, ha nem talal hibakezelest hasznalunk. A bad_alloc kivetelt melynek mukodsehez marad memoria, es a new_hanler-t hivjuk meg elotte ha nem talal memoriat a malloc. A konstruktoroknak alapvetoen nincs visszateresi ertekuk igy hibas allapotu objektumot hozhatunk letre vagy globalis valtozoval ellenorizzuk az objektum letrehozas sikeresseget vagy ne hozzunk letre kezdeti erteket vagy kezdeti ertek helyett egy tagfuggveny adjon erteket mely jelenti a hibat. Ezeknek a felhasznaloi ellenorzesevel kivetelkezelhetjuk a konstruktorokat. A destruktor meghivodhat a verem visszatekerese kozben ha elhagyunk egy megfelelo objektumot. Ha egy kivetelt nem kapunk el akkor a terminate fuggveny kerul meghivasra vagy ha a kivetelkezelo eljaras a vermet hibasnak talalja vagy egy delete kivetel kivaltassal probal veget erni. A terminate fuggveny meghivodasa meghivja az abort fuggvenyt amely kilep a programbol nem feltetlenul szabalyosan es az exit fuggvennyel ellentetben ennek nincs visszateresi erteke arrol hogy szabalyosan allt e le a program vagy nem. Egy elakapott kivetel nem mindig jelenti a program hibajat.
	</para>
   </section>  
   <section>
        <title>C++: Benedek Zoltán, Levendovszky Tihamér Szoftverfejlesztés C++ nyelven es Java: Nyékyné Dr. Gaizler Judit et al. Java 2 útikalauz programozóknak 5.0 I-II.</title>

        <para>
	A C++ es a Java egyarant objektum-orientalt programozasi nyelv, megis mind a C++, mind a Java programozasi nyelv sok szempontbol kulonbozik egymastol. A C++ programozasi nyelv alatamasztja mind az eljárasi, mind az objektum-orientalt programozast, ily modon hibridnek nevezik. A C++ es a Java programozasi nyelvek eltero tervezesi celokkal keszultek. A C++ programozasi nyelv alkalmazasok es rendszerek fejlesztesere kerult bevezetesre es a C programozasi nyelv kiterjesztese. A C++ programozasi nyelv az eljarasi nyelv tulajdonsagai mellett tamogatast nyujtott az objektum-orientalt programozasi szolgaltatasokhoz, a kivetelkezeleshez, az altalanos programozashoz. A Java programozasi nyelv ertelmezo funkcioval rendelkezik olyan nyomtatasi rendszerek szamara, amelyek kesobb tamogattak a halozati szamitast. A Java programozasi nyelv egy virtualis mehanizmusra epul, amely nagyon biztonsagos és hordozhato a programozasi kornyezetben. A Java programozasi nyelv csoportositva van egy szeleskoru konyvtarral, amely a meglevo platform absztrakciojanak tamogatasa erdekeben van megvalositva. A Java programozasi nyelv fejlesztesének fo celja egy konnyen hasznalhato es szeles korben elerheto programozasi nyelv kifejlesztese volt. A C++ es a Java programpzasi nyelvek is statisztikailag tipizalt objektum-orientalt programozasi nyelvek, hasonlo inkompatibilis szintaxissal rendelkeznek. A Java programozasi nyelv kiterjedt dokumentációval is rendelkezik, amely Javadoc néven ismert. A C++ programozasi nyelv mutatokat hasznal, mig a Java progrmozasi nyelv nem tartalmaz mutatokat. A Java a „korlatozott mutatok” fogalmat hasznalja. A korlatozza minosito alkalmazhato egy adatmutatora annak jelzesere, hogy a mutato deklaraciojanak hatalya alatt az osszes rajta elerheto adat csak az adott mutaton keresztul, de mas mutaton keresztul nem erheto el, igy lehetove teszi a forditonak bizonyos optimalizalasok elvegzeset azon felteves alapjan. A C++ programozasi nyelvben a program fut es a forditas a fordito hasznalataval tortenik. A C++ programozasi nyelv forditoja konvertalja a forraskodot gepi szintu nyelvre, ami a C++ programozasi nyelvet platformfuggetlen nyelvve teszi. A Java programozasi nyelvben a java forraskodot eloszor bajtkodra konvertaljak a forditaskor. Ezt a bajtkodot azutan az ertelmezo futasi ido alatt ertelmezi, hogy eloallitsa a kimenetet, ez teszi a Java programozasi nyelvet platformfuggetlen nyelvve. A C++ programozasi nyelv nem nyujt beepitett tamogatast a szalakhoz, mig a Java programozasi nyelv tamogatja a szalakat implicit modon. Noha a C++11 progrmazasi nyelv legujabb megvalositasaban tamogatja a szalakat is. A Java programozasi nyelv nagyjabol hasonlit a C++ programozasi nyelvre, de nem foglal magaban olyan osszetett fogalmakat, mint a strukturak, az operatorok tulterhelese, mutatok, sablonok, egyesitesek stb. A Java programozasi nyelv szinten nem tamogatja a felteteles forditast (# ifdef / # ifdef tipus). A Java programozasi nyelvben minden entitas a java targya, az alaptipusok kivetelevel. A Java programozasi nyelv egyetlen gyokerhierarchiaval rendelkezik, mivel minden a java.lang.Object fajlbol szarmazik. A C++ és Java programozasi nyelvek tamogatjak az OOPS koncepciokat. A C++ programozasi nyelv rugalmassagot nyujt futasi idoben es szeles tipusu hierarchiakat tud vegrehajtani. A C++ programozasi nyelv a C programozasi nyelvre epul es a funkcioival visszafele kompatibilis. A C++ programozasi nyelv egy egyfajta alacsony szintu programozasi nyelv nehany magas szintu funkcioval kiegeszitve. A C++ programozasi nyelv memoriakezelese egy kezi folyamat, amelyet a programozonak kell kezelnie, amely eloidezheti a memoriaszivargasok es a szegmentacios hibak kockazatat. A Java programozasi nyelv beepitett hulladekgyujto mechanizmussal rendelkezik amely nyomon koveti az objektumok szamara kiosztott memoriat es automatikusan felszabaditja azokat amikor mar nem hasznaljak. A Java progrmozasi nyelv kulonbozo primitiveket es objektumtipusokat kinal es erosen tipizalt programozási nyelv, ez lehetove teszi a primitivumok megfelelo objektumtipusokka torteno atalakitasat, peldaul egesz szamu objektumma egesz osztaly objektum felhasznalasaval stb. A Java programozasi nyelv automatikus polimorfizmust biztosit es korlatozhatja azt az explicit modszer felulbiralatanak megtiltasaval. Mind a C++, mind a Java programozasi nyelv rendelkezik hozzaferesi specifikatorokkal amelyek korlatozzak az attributumok és metodusok hatokoret, az osztalyon belul privat, a csomagon belul vedett, az osztalyon valamint a csomagon kivul nyilvanos. A C++ programozasi nyelv tamogatja a mutatokat, strukturakat, egyesiteseket, sablonokat, operatorok tulterheleset vagy a mutatok szamtani hasznalatat. Java programozasi nyelvben ezek nem talalhatoak meg, hanem referenciak vannak amiket nyers cimme nem lehet visszafejteni es a veszelyes valtoztatasok nem engedelyezettek. A referenciaknak tipusaik vannak es biztonsagosak. A C++ programozasi nyelvben destruktor meghivodik amikor egy objektum torlodik, Java programozasi nyelvben a garbage collection vegzi el automatikusan a memoriafelszabaditast. A C++ programozasi nyelv támogatja a feltételes összeállítást és beillesztést, a Java programozasi nyelv nem. A Java programozasi nyelv rendelkezik a fugggveny tulterhelesevel, de nincs operator tulterheles. A sztring osztaly a + es + = operatorokkal hasznalja a sztringek osszekapcsolasat es a karakterlanc kifejezesek automatikus tipuskonverziot hasznalnak, de ez egy specialis beepített eset. A C++ programozasi nyelv tamogatja a technika tulterheleset es az adminisztratorok tulterheleset. A Java programozasi nyelv beepitett tamogatast nyujt a dokumentacios megjegyzesekhez (/ **… * /); ezert a Java forrasfajlok tartalmazhatjak a sajat dokumentaciojukat, amelyet egy kulon eszköz olvas, altalaban Java doc es ujraformazzak HTML-re, ez elosegiti a dokumentacio egyszeru karbantartasat. A C++ programozasi nyelv nem tamogatja a dokumentacios megjegyzeseket. A C++ programozasi nyelv protestalo kodot hoz letre es lehet, hogy egy hasonlo kod nem fut kulonbozo szakaszokban, a Java programozasi nyelv platformfuggetlen.

	</para>
    </section>    
   <section>
        <title> Python: Forstner Bertalan, Ekler Péter, Kelényi Imre: Bevezetés a mobilprogramozásba</title>

        <para>
	A Python nyelvet Gudio van Rossum alkotta meg 1990-ben, ami objektumorientalt es platformfuggetlen igy hasznalhatjuk tobb platformon is peldaul Windows, Unix rendszereken, iPhone, mivel mobil eszkozokre is kifejlesztetettek. Fokent prototipusok tesztelesere hasznaljuk, mivel az alkalmazasok futtatasa es megirasa is kevesebb idot vesz igenybe mint a C++ illetve Java nyelv hasznaltnal. Mivel egy koztes nyelv igy nincs szukseg forditasra es linkelesre sem, es tomor es konnyen olvashato programokt keszithetunk mivel osszetett kifejezeseket hasznalhatunk, a tagolasnal nincs szukseg zarojelek hasznalatara, illetve nincs szukseg valtozo es argumentumdefinialasra sem. A Python szkriptnyelvek csoportjaba tartozik mivel a kodot a az ertelmezo,interper futas kozben ertelmezi, nem fordito hoz letre uj fajlt amit futtathatna gepi nyelven. Egy utasitas  a sor vegeig tart ha nem fer be egy sorba akkor a sor vegerere irt \ operatorral jelezzuk hogy az utasitas a kovetkezo sorban folytatodik. A nyelv szintaxisara behuzasalapau tagolas jellemzo tehat egy adott utasitasok csoportjanak veget egy kisebb behuzasu sor jelzi, tehat zarojeleket vagy kulcsszavakat nem hasznalunk tagolasra csak whitespaceket. A behuzasokat egysegesen kezeljuk vagy szokozt vagy tabulatorokat hasznaljunk illetve a szkript, kod elso utasitasa nem lehet behuzott. Az ertelmezo a sorokat tokenekre bontja, ami lehet azonosito, kulcsszo, operator, delimiter, literal. Az azonosito lehet egy valtozo, osztaly, fuggvenymodul, objektum neve, ami betuvel vagy alahuzassal kezdodhet es szamokat is tartalmazhat. A nagy es kis betuket megkulonboztetjuk egymastol. Kulcsszavak az and, assert, break, class, continue, def, del, elif, ekse, except, exec, finally, for, from, global, if, import, in, is, lambda, not, or, pass, print, raise, return, try, while, yield. Megjegyzesek elhelyezesere a # opratort hasznaljuk ami a sor vegeig ervenyes. A valtozok tipusait nem szukseges megadni mivel a hozzarendelt ertek alapjan a fordito automatikusan kitalalja azt. Az adattipusok a szamok, sztringek, ennesek, listak, szotarak. A szamok lehetnek egeszek, lebegopontosak, komplex szamok, oktalis formatum eseten bevezeto 0-t hasznalunk, hexadecimalis eseten 0x-et. Sztringeket idezojelek es aposztrofok kozt is megadhatunk, u hasznalataval pedig Unicode szoveggel. Az ennesek akar eltero tipusu objektumok vesszovel elvalasztva zarojelben. A lista akar kulonbozo tipusu elemek vesszovel elvalasztott rendezett sorozata szogletes zarojelben, az elemeket az indexukkel azonositjuk. A szotar akar kulonbozo tipusu elemek vesszovel elvalasztott rendezetlen sorozata, az elemeket kulcsukkal azonositjuk. A null erteket none a hasznalatos neve.  Minden adat objektum, a valtozok objektumokra mutato referenciak, ha egy objektumrol toroljuk az osszes hivatkozast a foglalalt memoriaterulet automatikusan felszabadul. A valtozo erteket a = jellel adhatjuk meg, a del kulcsszoval pedig torolhetjuk a valtozot. A fuggvenyben felvett valtozok lokalisak, a global kulcsszoval tehetjuk oket globalissa, igy a fuggvenyen kivul hasznalhatjuk oket. A kifejezeseket rovidithetjuk az alabbi modon a=b b=c -t a=c -re. A kulonbozo beepitett tipusok kozotti konverzio tamogatott: int, long, float, complex. A sztringeket, listakat, enneseket egyuttesen szekvenciaknak nevezzuk melyeken kulonbozo muveleteket hajthatunk vegre es beepitett fuggvenyeket alkalmazhatunk rajtuk. A len fuggveny visszadja a szekvencia hosszat, a min es max fuggveny a szelsoertekeket. A + jellel szekvenciakat fuzhetunk ossze, az a in s es a not in s a kifejezesek tartalmazasara adnak valaszt. A szekvenciak elemeit inexelessel lehet elerni 0-tol indulva, ha negativ indexet hasznalunk akkor a szekvencia vegetol szamitjuk az indexet, : jel hasznalataval pedig index intervallumot is megadhatunk. A szekvencia elemeit a del kulcsszoval torolhetjuk. A listakon vegezheto muveletek: count(e) visszadja e elofordulasainak a szamat, index(e) visszaadja e elso elofordulasanak az indexet, append(e) hozzafuzi e-t a lista vegere,extend(l) az l lista elemeit fuzi a lista vegere, insert(i,e) beszurja az e elemet az i-edik helyre, remove(e) eltavolitja e elso elofordulasat a listabol, pop[(i)] eltavolitja az i-edik elemet a listabol es visszadja annak erteket, ha az index nincs megadva az utolso elemmel vegzi el a muveletet, reverse helyben megforitja az elemek sorrendjet a listaban, sort[(f)] sorba rendezi a lista elemeit az f fuggveny segitsegevel, ha nincs megadva f fuggveny akkor a cmp fuggvenyt hasznlja. Szotaraknal is hasonloan alkalmazzuk a len, del, in operatorokat, a szotarak elemeit a szogletes zarojelben irt kulcs segitsegevel adhatjuk meg. A szotaraon vegezheto muveletek: copy() visszater a szotar egy masolataval, has_key(k) igaz erteket kapunk ha a k kulcs szerepel a szotarban, egyebkent hamis erteket, items() iteritems() a kulcsertek parok listajaval, illetve iteratoraval ter vissza, keys() iterkeys() a szotar kulcsait tartalmazo listaval, illetve iteratorral ter vissza, values() itervalues() a szotar ertekeit tartalmazo listaval, illetve iteratorral ter vissza, get(k[,x]) setdefault(k[,x]) visszater a k kulccsal jelolt elemmel, ha nem letezik az x ertekevel ter vissza, ha nem adunk meg x erteket akkor none lesz a visszateresi ertek, a setdefault emelett meg be is allitja a k kulcsu elemet x-re, clear() kitorli az osszes elemet a szotarbol, popitem() kitorol es visszaad egy tetszoleges elemet a szotarbol. A print segitegevel kiirathatunk az stdout-ra sztringeket vagy valtozokat, ezeket vesszovel elvalasztva kell megadni. Az if feltetel: utasitas elif feltetel: utasitas else: utasitast hasznalhatjuk feltelek megadasra. A for in segitsegevel barmely felsorolhato tipus elemein vegigmehetunk. A range(x,y,z) fuggveny egy listat general egesz ertekekbol x-tol y-ig z novekedessel, az xrange kevesebb memoriaigennyel mukodik. A while feltetel: utasitas segitsegevel addig hajtodik vegre az utasitas amig a feltetel igaz. A break kulcsszoval kilep a ciklusbol, a continue-val folytatja. Cimkeket a label kulcsszoval helyezhetunk el a kodban, a cimkere pedig a goto kulcsszoval ugorhatunk, a comefrom kulcsszoval pedig a label reszhez ugrik. Fuggvenyeket a def nev(): utasitas return modon hozhatunk letre. Definialhatunk osztalyokat az alabbi modon class osztalynev (ososztalyok): osztalytorzs. Az osztalyok oroklodhetnek mas osztalyokbol es peldanyaik az objektumok. Az ososztalyok mar deflialt osztalyok vesszovel elvalasztott listai, attribitumokat hozzaadhatunk az egyes osztalyokhoz es peldanyokhoz, ha modositjuk az olsztaly attribitumat akkor ez a hozzatartozo objektumokra is hatassal van. Objektumok es osztalyok valtozoira objektum/osztalynev.valtozonev segitsegevel hivatkozhatunk. Az osztalyok fuggvenyeit metodusnak nevezzuk es az elso paramtere a self kulcsszo kell hogy legyen, melynek erteke az objektumpeldany melyben a fuggvenyt meghivtak. Konstruktort is letrehozhatunk ami egy specialis fuggveny igy a def __init__(self): modon definialhatjuk. A specialis fuggvenyek, valtozok ket alulvonas jel kozze vannak irva. A Python a fejlesztes megkonnyitese erdekeben beepitett modulokat tartalmaz: appuifw a felhasznaloi felulet kialakulasat tamogatja, messaging az SMS es MMS uzenetek kezeleset konnyiti meg, sysinfo a mobilkeszulekekkel kapcsolatos informaciok lekerdezesere hasznalhato, camera segitsegevel vegezhetunk a keszulek kamerajaval kapcsolatos muveleteket, audio segitsegevel keszithetunk hangfelveteleket es le is jatszhatjuk azokat. A Python tamogatja a kivetelkezelest, a try blokkban keressuk a hibat majd a vezerles hiba eseten az except reszhez ugrik, ahol hasznalhatunk egy else agat is, az alabbi fromaban hasznaljuk try: utasitasok except [kifejezes]: utasitasok [else: utasitasok]. A finally: utasitas a try resz vegen fut le, a raise beiptett hibakra van.
	</para>
   </section>
</chapter> 
