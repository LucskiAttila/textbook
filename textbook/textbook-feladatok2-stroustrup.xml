<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>JDK osztályok</title>
     <para>
          Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
     </para>
     <para>
          A feladat megoldásához először is telepíteni kell a JDK osztályokat a gépünkre. A JDK állományok benne vannak például az openjdk-13 csomagban, amit letöltehetünk akár a java.net weboldalról a wget parancssori kifejezés használatával, melyet szükség esetén telepíthetünk a sudo apt-get install parancs segítségével a parancsossorban. Miután letöltöttük az állományt láthatjuk hogy tar kiterjesztése van. tehát egy tömörített fájl melyet a tar parancssori kifejezéssel kicsomagolhatunk a megfelelő kapcsolók használatával. Az xzvf kapcsolót használtam, melyben az x és z a lényegesebbek hogy kicsomagoljon és a gzip segítségégvel, a v kapcsolóval a folyamat végrehajtódását követhetjük nyomon a terminálban, az f kapcsolóval pedig engedélyezzük a névadást a létrejövő fájlnak, ami alapértelmezetten, ahogy csináltam megegyezik a tömörített fájl nevével. De ez nem fontos mivel mi az src.zip fájllal fogunk dolgozni, ami mivel zip kiterjesztésű így ez is egy tömtörített fájl csak más programot használunk a kicsomagolásához, ahogy a tömörítéshez is használtak. Az unzip csomagot hasznáéjuk a kitömörítéshez, de előtte a könyebb elérés érdekében, amit ugye az általunk írt program szükséges, a move kifejezéssel a jdk-s könyvtárból az általunk létrehozott gyökérkönyvtárba, amit ehhez a feladathoz hoztunk létre, ahova letöltöttük a fájlt és amibe dolgozunk áthelyeztem az src.zip fájlt. Ebbe a mappába a parancssorban eljuthatunk a cd parancsokkal, de egyszerűbb jobb klikkel a Megnyitás parancssorban utasítást használni. Az áthelyezéskor . karakter jelentése az aktuális könyvtár, azaz az általunk létrehozott gyökérkönyvtár. Illetve a helyes működéshez a már nem szükséges fájlokat törölhetjük az src parancssori kifejezés segítségével, az r és v kapcsolót használtam mivel a mappát almappáival együtt törlöm és láthatjuk hogy halad a folyamat, ehhez telepítenünk kell a secure-delete csomagot az apt install segítségével: 
          tar https://download.java.net/java/GA/jdk13/5b8a42f3905b406298b72d750b6919f6/33/GPL/openjdk-13_linux-x64_bin.tar.gz
          mv jdk-13/lib/src.zip .
          unzip src.zip
          apt get install secure-delete
          srm -rv jdk-13 src.zip openjdk-13_linux-x64_bin.tar.gz
          A feladat alapján boost C++ programot kell írnunk, ehhez azonban telepíteni kell a boost könyvtárakat, amiket tartalmaz például a libboost-all-dev csomag, amit a már általunk ismert apt-get install parancsori kifejezéssel tehetjük meg az alábbi módon:
          sudo apt-get install libboost-all-dev
          A programunkat a g++ fordítóval fordítjuk használva az alaábbi kapcsolókat:
          g++ program.cpp -o bejaro -lboost_system -lboost_filesystem -lboost_program_options -o p
          A program futtatása az általunk elnevezett névvel történik amit a fordításkor adtunk meg az o kapcsolóval , majd második paraméterként meg kell adnunk a /home könytvártól a létrehozott mappánk elérési útvobalát az alábbi módon:
          ./p /home/attila/Letöltések/jdk
          Ezt a programunk elején hibakezeltem is egy parancssori argumentumainak számának ellenőrző feltétellel. Ha teljesül akkor kapunk egy hibaüzenetet a program használatáról, ha nem akkor példányozzuk az src mappa könyvtárrendszerét, melyre meghívjuk az általunk megírt read_files függvényt ami végigmegy a könyvtárszerkezet mappáin és a return_vec nevű vektorba menti a java kiterjesztésű fájlokat melynek értékét értékül adjuk a paths vektornak. Így az src mappának a java kiterjesztésű fájlainak neveit tartalmazza a paths vektor, melynek elemein az auto &path :paths kifejezés segítségével, majd a fájlok tartalmainak eléréséhez használjuk az ifstream kifejezést, illetve a getline függvénnyel az adott fájl sorain megyünk végig egy végtelen ciklussal, amíg nem találjuk meg a fájl nevét egy class kifejezés mögött. Ha megtaláltuk a keresett sztringet az adott fájl valamely sorában akkor kiiratjuk a szabványos kimenetre a fájl elérési útvonalát zárójelben, illetve a zárójel előtt az adott JDK osztály nevét és növeljük az n változó értékét eggyel,  mivel megszámoljuk a JDK osztályainak számát. A keresést az if(l.find(findstr) != std::string::npos) kifejezéssel végeztük ami akkor lesz igaz ha a find paramétreként megadott objektum legalább egyszer szerepel a find által meghívott objektumban.  A break kifejezéssel tudunk kilépni a végtelen while ciklusból ha megtaláltuk a keresett kifejezést. A c_str függvényt akkor használjuk, ha egy adott objektumra egy C függvényt hívunk meg, ami C típusó sztringet vár paraméterül, így meghívjuk rá a c_str függvényt a helyes működés érdekében. A stem függvény segítségével kapjuk meg a JDK osztályok neveit a fájnevükből, melyek java kiterjesztésűek és tartalmazzák a fájlenevet főosztályként.
      </para>
      <programlisting language = "C++"><![CDATA[
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

std::vector<boost::filesystem::path> return_vec;
std::vector<boost::filesystem::path>
read_files(const boost::filesystem::path path) {
    if (is_regular_file(path)) {
        std::string ext(".java");	// We only care about .java files
        if ( ! ext.compare(boost::filesystem::extension(path))) {
            return_vec.push_back(path);
        }
    } else if (is_directory(path)) {
        for (boost::filesystem::directory_entry & entry
                :
                boost::filesystem::directory_iterator(path)) {
            read_files(entry.path());
        }
    }
    return return_vec;
}
int
main(int argc, char **argv) {
    if(argc!=2){
    std::cout << "Usage: ./<filename> <path>" << std:endl;
    return -1;
    }
    else{
    boost::filesystem::path sources_path { argv[1] };
    std::vector<boost::filesystem::path> paths = read_files(sources_path);
    std::string l;
    int n = 0;
    for (auto const &path : paths) {
        std::ifstream in(path.c_str());
        if (in) {
            while (std::getline(in, l)) {
                std::string find_str = "class " + path.stem().string();
                if (l.find(find_str) != std::string::npos) {
                    std::cout
                        << path.stem().c_str()
                        << " (file: " << path << ")"
                        << std::endl;
                    n++;
                    break;
                }
            }
        }
    }
    std::cout
        << "There are "
        << n
        << " classes in JDK (sources dir: " << sources_path << ")."
        << std::endl;
    return 0;
}
}
           ]]>
        </programlisting>
      	   <mediaobject>
            <imageobject>
                <imagedata fileref="jdk1.png"></imagedata>
            </imageobject>
        </mediaobject>
	    	   <mediaobject>
            <imageobject>
                <imagedata fileref="jdk.png"></imagedata>
            </imageobject>
        </mediaobject>
     </section>
    
    <section>
	     <title>Másoló-mozgató szemantika</title>
	     <para>
              Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra! 
        </para>    
        <para>
             A konstruktorok segítségével példányosítjuk az osztályokat, kezdőértéket adunk nekik ezzel létrehozzuk az objektumokat. A konstruktor nevének meg kell egyeznie annak az osztálynak a nevével amelyikre meghívtuk, a létrehozott objektumok által lefoglalt tárterületet a destruktorok segítségével szabadítjuk fel, melynek a neve megeyezik az osztályéval és ~ jel van előtte. 
	     Ha a konstruktorok paraméterének objektumokat adunk meg akkor meghívódik a másoló konstruktor, ami létrehozza létrehoz egy új objektumot a paraméterként megadott azonos osztálybeli objektum értékéivel: 
		osztály(const osztály& paraméter){
		size_t size = strlen(paraméter.adat);
		data = new char[size-1];
		memcpy(adat, paraméter.adat, size);
		}
	     Ez a kódcsipet hívódik meg ha egy osztály típusú objektumot próbálunk létrehozni egy másik osztály típusú objektum segítségével, annak értékeievel. A konstruktort úgy definiáltuk hogy megnézi a másolandó objektum változójának méretét, majd lefoglal annyi méretet az aktuális objektum ugyanazon nevű változójába, majd a memcpy függvénnyel átmásoljuk a paraméter objektum adott heap memória tartalmát amit a változó névvel azonosítunk a hozzátartozó aktuális objektumba. A new kifejezéssel heapen lefoglalt memóriát a delte függvénnyel nekünk kellessz törölni, jelen esetben delete data[] mivel memóriatömbről van szó.
	     A másoló értékadás akkor hívódik meg ha két már létező azonos osztálybeli objektum közt egyenlőség jel van, ekkor nyilván a baloldali objektumnak akarjuk értékül adni a jobb oldali objektumot. Ehhez túlterheltük az egyenlőségjel operátort:
		osztály& operator=osztály(const osztály& paraméter){
		size_t size = strlen(const paraméter.adat);
		data = new char[size-1];
		memcpy(adat, paraméter.adat, size);
		return *this
		}
	     Itt is hasonló művelet hajtódik végre mint a másoló konstruktornál, de ennek a konstruktornak lesz visszatérési értéke mégpedig a dereferenciált this kifejezés, ami az aktuális objektum memóriacíme, *-gal viszont maga az objektum.
	     Amint láthatjuk mindkét esetben megmaradt az eredeti objektum heapen foglalt területe és emellé hoztunk létre egy újat ugyanazon értékekekkel. Azonban ha nincs szükségünk már az eredeti objektumunk egyes részeire és ezeket egy másik hasonló osztálybeli objektumban akarjuk tovább használni akkor hasznos a C++11 által bevezetett mozgató szemantikák, azaz a mozgató konstruktor és mozgató értékadás. Ezek akkor hívódnak meg ha a konstruktor objektuma jobbérték típusú kell hogy legyen, mivel ha alapértelmezettként balérték típusú akkor a másolószemntika hívódna meg. Ezek definiálásakor &&-et használunk referenciának:
		osztály (osztály&& paraméter ){
		adat = paraméter.adat;
		paraméter.adat = nullptr;
		}
	     Amint láthatjuk a mozgató konstruktor esetén, ami akkor hívódik meg ha létrehakarunk hozni jobbérték objektumból vele azonos osztálybeli objektumot, az átmozgatni kívánt változó memóriacímét értékül adtuk az aktuális objektuméhoz tartozó változónak, majd az eredeti objektuménak nullptr értéket adtunk, így töröltük. Mivel törlés nélkül probléma lett volna a memóriafelszabadításkor is mivel két változó is ugyanarra a memóriacímre mutatott és C++ ezeket nekünk kell törölni és a duplatörlés memóriaszivárágst eredményezhet. Egyébként Java nyelvben az objektumoknak csak a nevét kell módosítani, azaz több objektum használhatja ugyanazt a memóriacímet így ha módosul az egyik, vele módosul a másik, azonban itt a memóriafelszabadítás automatikusan végződik a garbage collapter segítségével.
	     A mozgató értékadás akkor hívódik meg ha egynelőség jelet használunk két azonos típósó objektum között, melynek jobb oldalán jobbértékű, baloldalán balértékű objektum szerepel:
		osztály& operator=osztály(const osztály&& paraméter){
		swap(adat,paraméter.adat);
		return *this;
		}
	     Ez is hasonló szemantikájú a másoló konstruktorhoz annyiban hogy az egyenlőség jel operátort terheljük túl benne, azaz átdefiniáljuk a működését az alapértelmezettől eltérő módon. Itt a swap függvény segítségével felcseréljük az átadni kívánt változók értékeit, így egymás már egymás memóriacímeire fognak mutatni, itt az adat alapértelmezettként nullptr.	
	     A feladat alapján a mozgató konstruktorunkat alapoznunk kell a mozgató értékadásra:
		osztály (osztály&& paraméter ){
		adat = nullptr;
		*this = move(paraméter);
		}
		osztály& operator=osztály(const osztály&& paraméter){
		swap(adat, paraméter.adat);
		return *this
		}
	      Ez ugye akkor hívódik meg amikor a mozgató konstruktorba ágyazzuk a mozgató értékadást és hasonlóképpen működik a mozgató konstruktorhoz. Először is nullptr értéket adjuk az aktuális objektum adat változójának, aminek az értékét ugye felakarjuk cserélni a paraméterként adott objektuméval, ehhez segítségül hívjuk a mozgató értékadást amiben ugyanis értelmezett a swap függvény. Ahhoz hogy meghívjuk a move függvénnyel jobbértékűre kell állítanunk a paraméter objektum típusát baloldaliról, így egyenlővé téve az aktuális objektumunkkal. Ezzel teljesül a feltétetele a mozgató értékadásnak és meg is hívódik, ami azt eredményezi hogy a mozgató értékadás által megfelően módosított objektumot értékül adjuk a mozgató konstruktor aktuális objektumának. 
	    </para>
	</section>
	
    <section>
	     <title>Hibásan implementált RSA törése</title>
	     <para>
		  Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló: https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71 73 fólia) által készített titkos szövegen.
	    </para>
	<para>
	A Java a JDK 1.1 verziótól tartalmaz két új osztályt, a BigIntegert és a BigDecimalt. Az osztályokat azzal a szándékkal fejlesztették ki, hogy megkönnyítsék azoknak a munkáját, akiknek a Long nem elég nagy, illetve a Float osztály nem elég pontos.
	A BigDecimal osztály tetszőleges pontosságú előjeles valós szám ábrázolására alkalmas, amely már a Java 1.1 verziótól a java.math csomag része és amelyet a J25E 5.0 verziótól valódi lebegőpontos műveletekkel is kiegészítettek. A típus egy tetszőlegesen nagy egész értékből és egy nem negatív 32-bites egészből, a skálázó faktorból áll. Pl. a 123.456 valós számot BigDecimalként felírva a típus egész értéke 123456, míg a skálázó faktor értéke 3.
	    </para>
<programlisting language="Java"><![CDATA[
//helyes megoldás:
BigDecimal a = new BigDecimal("123.456");
//helytelen megoldás:
BigDecimal a = new BigDecimal(" 123.456");
]]>
</programlisting>
	<para>
	Az eltérő skálázó értékkel rendelkező számaink nem egyenlőek:
	    </para>
		<programlisting language="Java"><![CDATA[
class Main {
    public static void main(String[] args) {
        BigDecimal a = new BigDecimal("1.23");
        BigDecimal b = new BigDecimal("1.230");
        System.out.println(a.equals(b)); //false lesz
        System.out.println(a.compareTo(b)); //0, stringként megegyeznek]]>
</programlisting>
	<para>
A BigInteger osztály egy érdekes használata a számelmélet egy speciális területe: a nagy értékű kongruenciák vizsgálata, a hozzákapcsolódó moduló műveletek, valamint a nagy prímszámok előállítása, illetve megbízható prímtesztek. A jelentőséget az adja ennek a matematikai területnek, hogy különös módon összefonódott a kriptográfiával; a biztonságos üzenetküldés problematikájával. A nyilvános kulcsú rejtjelezés alapötlete, hogy a kódolás, titkosítás folyamatát elválasztja a dekódolástól, és olyan algoritmust használ, ahol a kódoláshoz használt paraméter nem azonos a dekódoláshoz használt paraméterrel, és a kódoláshoz használt paraméterből nem határozható meg a dekódoláshoz szükséges paraméter. A nyilvános kulcsú rejtjelezés legelterjedtebb módszere az 1978-ban publikált RSA algoritmus, amely nevét alkotóinak kezdőbetűjéből kapta.
Az RSA (Ronald L. Rivest, Adi Shamir, Leon Adleman) aszimmetrikus algoritmus egy matematikai tételen (Fermat-tétel) alapszik, amely kimondja, hogy ha p prímszám és nem osztója egy a egész számnak, akkor a^(p-1)-1 osztható a p számmal.
Vegyünk először két véletlenszerű nagy prímszámot, p-t és q-t, n = pq. Amennyiben p értéke 5 és q értéke 7, úgy n értéke 35 lesz értelemszerűen. Ezután vegyünk egy olyan kis páratlan e számot, amely relatív prím fí(n) = (p-1)(q-1)-hez. Amennyiben maradunk a korábbi példaértékeknél, úgy 24-et kapunk fí(n)-re, e értéke pedig 7 lesz (relatív prím 24-hez). Keressünk egy olyan d számot, amely ed = 1 mod fí(n). Mivel e értéke 7, ezért e*d = 7*31 = 1 mod 24 lesz. Az RSA nyilvános kulcs a P = (e,n) pár lesz (P = (7,35)), az RSA titkos kulcs az S = (d,n) pár lesz (S = (31,35).
Az RSA titkosításra vonatkozó ellenőrzési eljárások közül talán a legismertebb a Solovay-Strassen teszt, illetve a Miller-Rabin teszt. Utóbbi a következő tényeken alapszik: legyen n egy páratlan prím, és n-1 = 2*r, ahol r egy páratlan szám. Legyen a egy tetszőleges egész úgy, hogy gcd(a,n) = 1. Ekkor mind az a^r = 1 (modn), mind az a^2^jr = -1 mod(n) igaz, bármely j értékre.
A Miller-Rabin prímteszt pedig a következő: MILLER-RABIN(n,t). A bemenő érték egy páratlan 3-nál nagyobb vagy egyenlő egész és egy t egynél nagyobb biztonsági paraméter. A kimenő paraméter egy válasz, "prím" vagy "összetett" az n számunk.
Az RSA összefoglalója után következhet a "Hibásan implementált RSA törése".
A feladat megoldásához kapott forrás alapján így néz ki a kulcsgenerálás:
	</para>
	<programlisting language="Java"><![CDATA[
public class RSA{
	public static void main(String[] args)
	{ 	
        int meretBitekben = (int) (700 * (int) (java.lang.Math.log( (double) 10)) / java.lang.Math.log((double) 2));
		System.out.println("Méret bitekben: ");
		System.out.println(meretBitekben);
		java.math.BigInteger p_i = new java.math.BigInteger(meretBitekben, 100, new java.util.Random() );
		System.out.println("p_i");
		System.out.println(p_i);
		System.out.println("p_i hexa");
		System.out.println(p_i.toString(16));
		java.math.BigInteger q_i = new java.math.BigInteger(meretBitekben, 100, new java.util.Random() );
		System.out.println("q_i");
		System.out.println(q_i);
		java.math.BigInteger m_i =p_i.multiply(q_i);
		System.out.println("m_i");
                System.out.println(m_i);
		java.math.BigInteger z_i = p_i.subtract(java.math.BigInteger.ONE).multiply(q_i.subtract(java.math.BigInteger.ONE));
		System.out.println("z_i");
		System.out.println(z_i);
        	java.math.BigInteger d_i;
		do {
			do {
				d_i = new java.math.BigInteger(meretBitekben, new java.util.Random());
			} while(d_i.equals(java.math.BigInteger.ONE));
		} while(!z_i.gcd(d_i).equals(java.math.BigInteger.ONE));		
		System.out.println("d_i");
		System.out.println(d_i);
		java.math.BigInteger e_i = d_i.modInverse(z_i);
		System.out.println("e_i");
		System.out.println(e_i);
	}
}]]>
	</programlisting>
<para>
A fordítást és futtatást követően megkapjuk a hibás implementáció alapján létrejövő kulcsokat:
</para>
<mediaobject>
<imageobject>
<imagedata fileref="rsa.PNG" format="PNG" scale="45"/>
</imageobject>
</mediaobject>
<para>
Az RSA titkosításhoz egy titkos és egy nyilvános kulcsot használunk. Először létrehozzuk a modulust, a kitevőt és annak inverzét a KulcsPar osztályban. A p és a q lesz a két nagy prímszámunk, melyeket összeszorozva kapjuk meg a modulus értékét.
</para>
<programlisting language="Java"><![CDATA[
public class RSA2{
static class KulcsPar{
  java.math.BigInteger d, e, m;
  public KulcsPar(){
      int meretBitekben = 700 * (int) (java.lang.Math.log((double) 10) / java.lang.Math.log((double) 2));
      java.math.BigInteger p = new java.math.BigInteger(meretBitekben, 100, new java.util.Random());
      java.math.BigInteger q = new java.math.BigInteger(meretBitekben, 100, new java.util.Random());
      m = p.multiply(q);
      java.math.BigInteger z = p.subtract(java.math.BigInteger.ONE).multiply(q.subtract(java.math.BigInteger.ONE));
      do {
        do {
            d = new java.math.BigInteger(meretBitekben, new java.util.Random());
          } while (d.equals(java.math.BigInteger.ONE));
        } while (!z.gcd(d).equals(java.math.BigInteger.ONE));
      e = d.modInverse(z);
    }
  }]]>
  </programlisting>
<para>
A titkosítás lényege, hogy a titkos szöveget kell feltölteni a tiszta szöveg ASCII kódjával. A modPow függvénynek megadjuk az exponenst (hatványkitevőt), majd a modulust, így az ASCII kódból nagy integert kapunk.
</para>
<programlisting language="Java"><![CDATA[
public static void main(String[] args){
    KulcsPar jSzereplo = new KulcsPar();
    String tisztaSzoveg = "Utra kelunk. Megyunk az Oszbe, Vijjogva, sirva, kergetozve, Ket lankadt szarnyu heja-madar.";
    byte[] buffer = tisztaSzoveg.getBytes();
    java.math.BigInteger[] titkos = new java.math.BigInteger[buffer.length];
    for(int i = 0; i < titkos.length; i++)
      {
        titkos[i] = new java.math.BigInteger(new byte[]{buffer[i]});
        titkos[i] = titkos[i].modPow(jSzereplo.e, jSzereplo.m);
      }]]>
</programlisting>
<para>
Visszafejtéskor ismét igénybe vesszük ezt a függvényt, ezúttal viszont az első paraméter a kitevő inverze (d) lesz, így a nagy integerből ismét ASCII kód lesz. A buffer tömbbe ezt betöltve megkapjuk stringként a korábban megadott tiszta szöveget.
</para>
<programlisting language="Java"><![CDATA[
    for(int i = 0; i < titkos.length; i++)
      {
        titkos[i] = titkos[i].modPow(jSzereplo.d, jSzereplo.m);
        buffer[i] = titkos[i].byteValue();
      }
    System.out.println(new String(buffer));
    }
  }]]>
  </programlisting>
<para>
Fordítás és futtatás esetén az RSA titkosítás alapján visszafejtett szöveget kapjuk vissza.
<mediaobject>
<imageobject>
<imagedata fileref="rsa2.PNG" format="PNG" scale="100"/>
</imageobject>
</mediaobject>
</para>
    </section>


    <section>
        <title>Változó argumentumszámú ctor</title>
        <para>
		Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű képet ” adjon vissza. (Lásd még a 4hét/Perceptron osztály feladatot is.)
	    </para>	
        <para>
A Benoît Mandelbrot nevéhez köthető Mandelbrot-halmaz a komplex számsíkon ábrázolva egy fraktálalakzatot jelent. A kétdimenziós halmaz png ábráját fogjuk először létrehozni a <filename>mandel.cpp</filename> file segítségével.
<programlisting language="C++"><![CDATA[
$ more mandel.cpp
#include <iostream>
#include "png++/png.hpp"
int main (int argc, char *argv[])
{
    if (argc != 2) {
        std::cout << "Hasznalat: ./mandelpng fajlnev";
        return -1;
    }
    double a = -2.0, b = .7,  c = -1.35, d = 1.35;
    int szelesseg = 600, magassag = 600, iteraciosHatar = 1000;
    png::image <png::rgb_pixel> kep (szelesseg, magassag);
    double dx = (b-a)/szelesseg;
    double dy = (d-c)/magassag;
    double reC, imC, reZ, imZ, ujreZ, ujimZ;
    int iteracio = 0;
    std::cout << "Szamitas";
    for (int j=0; j<magassag; ++j) {
        for (int k=0; k<szelesseg; ++k) {
            reC = a+k*dx;
            imC = d-j*dy;
            reZ = 0;
            imZ = 0;
            iteracio = 0;
            while (reZ*reZ + imZ*imZ < 4 && iteracio < iteraciosHatar) {
                ujreZ = reZ*reZ - imZ*imZ + reC;
                ujimZ = 2*reZ*imZ + imC;
                reZ = ujreZ;
                imZ = ujimZ;
                ++iteracio;
             }
            kep.set_pixel(k, j, png::rgb_pixel(255-iteracio%256,
                                               255-iteracio%256, 255-iteracio%256));
        }
        std::cout << "." << std::flush;
    }
    kep.write (argv[1]);
    std::cout << argv[1] << " mentve" << std::endl;
}]]>
</programlisting>
Ahogy látjuk, a <filename>mandel.cpp</filename> sikeres fordításához és futtatásához szükségünk lesz a libpng, libpng++ könyvtárakra és a <filename>png++/png.hpp</filename> header filera. A könyvtárakat a sudo parancs segítségével tudjuk telepíteni, viszont a headerhez le kell töltenünk a png++ hivatalos oldaláról a becsomagolt telepítő állományokat: <link xlink:href="http://download.savannah.nongnu.org/releases/pngpp/png++-0.2.9.tar.gz">png++-0.2.9.tar.gz</link>
<programlisting><![CDATA[
//A terminálba leadott parancsok:
$ sudo apt-get install libpng-dev
$ sudo apt-get install libpng++-dev
$ tar -zxf png++-0.2.9.tar.gz -C ~/Letöltések
$ cd ~/Letöltések/png++-0.2.9
$ make]]>
</programlisting>
Ha minden jól megy, mostmár tudjuk fordítani és futtatni a png elkészítéséhez szükséges programot.
<programlisting><![CDATA[
$ g++ mandel.cpp `libpng-config --ldflags` -o mandel
$ ./mandel mandel.png
Szamitas......................................mandel.png mentve]]>
</programlisting>
<mediaobject>
            <imageobject>
            <imagedata fileref="mandel.png" format="PNG" scale="50"/>
            </imageobject>
        </mediaobject>
</para>
<para>
A perceptron az egyik legegyszerűbb előrecsatolt neurális hálózat. A <filename>main.cpp</filename> segítségével fogjuk szimulálni a hiba-visszaterjesztéses módszert, mely a többrétegű perceptronok (MLP) egyik legfőbb tanítási módszere. Ahhoz, hogy ezt fordítani és futtatni tudjuk később, szükségünk lesz az <filename>mlp.hpp</filename> header filera, mely már tartalmazza a Perceptron osztályt.
Az előző program futtatásával létrejött Mandelbrot png ábrát fogjuk beimportálni. A header filenak köszönhetően megadhatjuk a rétegek számát, illetve a neuronok darabszámát. A beolvasásra kerülő kép piros részeit a lefoglalt tárba másoljuk bele. A <filename>mandel.png</filename> alapján új képet állítunk elő, mely megkapja az eredeti kép magasságát és szélességét. A visszakapott értékeket megfeleltetjük a blue értékeknek.
</para>
<programlisting language="C++"><![CDATA[
#include <iostream>
#include "mlp.hpp"
#include <png++/png.hpp>
#include <fstream>

int main (int argc, char **argv)
{
	png::image <png::rgb_pixel> png_image (argv[1]);
	int size = png_image.get_width() *png_image.get_height();
	Perceptron* p = new Perceptron (3, size, 256, size);
	double* image = new double[size];
	for (int i {0}; i<png_image.get_width(); ++i)
		for (int j {0}; j<png_image.get_height(); ++j)
			image[i*png_image.get_width() +j] = png_image[i][j].red;
	double* newimage = (*p) (image);
    for (int i = 0; i<png_image.get_width(); ++i)
          	for (int j = 0; j<png_image.get_height(); ++j)
			png_image[i][j].blue = newimage[i*png_image.get_width()+j];
    png_image.write("output.png");
	delete p;
	delete [] image;
}]]>
</programlisting>
<para>
Az első felvonás Perceptron feladatához képest módosításokat kell végeznünk a header file-on is, ugyanis új képet akarunk előállítani. A double pointer () operátor már egy tömböt térít vissza, melynek segítségével bele tudunk nyúlni a képbe. Az utolsó units tömb értékei átkerülnek a paraméterként kapott tömbbe, az eredeti és az új kép egyforma méretű lesz.
</para>
<programlisting language="C++"><![CDATA[
double* operator() ( double image [] )
  {
    units[0] = image;
    for ( int i {1}; i < n_layers; ++i )
      {
#ifdef CUDA_PRCPS
        cuda_layer ( i, n_units, units, weights );
#else
        #pragma omp parallel for
        for ( int j = 0; j < n_units[i]; ++j )
          {
            units[i][j] = 0.0;
            for ( int k = 0; k < n_units[i-1]; ++k )
              {
                units[i][j] += weights[i-1][j][k] * units[i-1][k];
              }
            units[i][j] = sigmoid ( units[i][j] );
          }
#endif
      }
    for (int i = 0; i < n_units[n_layers - 1]; i++)
        image[i] = units[n_layers - 1][i];
    return image;
  }]]>
</programlisting>
<para>
A fordításhoz a C++11 szabványt használjuk, futtatáskor pedig megadjuk annak a képfájlnak a nevét és kiterjesztését, amelyet be kívánunk olvasni (a <filename>mandel.cpp</filename>-ből kapott <filename>mandel.png</filename> ábra).
</para>
<mediaobject>
<imageobject>
<imagedata fileref="perceptron1.PNG" format="PNG" scale="65"/>
</imageobject>
</mediaobject>
    </section>
 
    <section>

        <title>Összefoglaló</title>
        <para>
            Az előző 4 feladat egyikéről írj egy 1 oldalas bemutató „esszé" szöveget!
        </para>
        <para>
            <emphasis role="strong">A mozgató és másoló konstruktor</emphasis>
        </para>
        <para>
            A C++ objektum oreintált nyelv, vagyis lehetőséget biztosít a polimorfizmusra, az egységbezárást, és az adatrejtést. Definiálhatunk benne 
            osztályokat, melyek olyan tagfüggvénnyel rendelkező struktúráknak lehet nevezni, természetesen kibővítve az objektum orientáltság alapelveivel.
            Amikor egy osztályt példányosítunk, akkor az osztály konstruktora hívódik meg. Ha nem definiálunk konstruktort, akkor a fordító az alapértelmezett
            konstruktort használja. A konstruktorok olyan függvények, melyeknek feladata az objektum inicializálása. Vagyis ebben szoktunk a 
            az egyes tagváltozóknak értéket adni, bizonyos tagfüggvényeket meghívni, melyek szükséegese az objektum alapjának elkészítéséhez. Egy másik
            szembetűnő tulajdonsága a konstruktoroknak, hogy a nevük megegyezik az osztály nevével. A konstruktor ellentéte a destruktor, mely az objektum 
            törlésével együtt hívódik meg, és felszabadítja a már nem használt memóriaterületeket. Egy jól megírt C++ programban viszont nem elég ennek a 
            kettőnek a megléte, szükség van még másoló és mozgató konstruktorokra.
            A másoló és mozgató konstruktorok segítségével szintén objektumok inicializálását hajthatjuk végre, viszont egy másik azonos osztályú objektum
            alapján. Ha nem szeretnénk megírni ezeket, akkor a legegyszerűbb, ha letiltjuk használatukat, vagyis privát taggá tesszük őket. Erre azért van szükség,
            mert ha nem tiltjuk le őket, akkor a fordító az alapértelmezett másoló/mozgató konstruktort hívja meg, ami váratlan eredményekhez vezethet, kiszámíthatatlanná
            teszi a program működését. 
            A másoló konstruktor, ahogy a nevében is benne van egy objektumot másol le, és az alapján készít egy másikat. Onnan lehet felismerni, hogy 
            paraméterként mindig az őt magábafoglaló osztállyal azonos osztályú objektumrefenciát vár. Két fajta másolásról beszélhetünk: sekély és mély 
            másolás. A sekély másolás lényege, hogy csak létrehozunk egy másik mutatót, ami a paraméterként megadott onjektumra mutat. Ennek implementálása a 
            legegszerűbb, viszont használata problémákat okozhat. A legfőbb hátrány eme megoldási módnak, hogy közös a memóriaterület, tehát ha az egyiket
            módosítjuk, akkor az a másikr is kifejti hatását. Tehát ez nem egy igazi másolat, nevezhetnénk alias-nak. A mély másolás ezzel szemben egy különálló 
            onjektumot hoz létre, mely megegyezik a paraméterül kapott elemmel, viszont külön memóriacímen. Sekély társához képest implementálása összetettebb,
            viszont magabiztos használata jobb C++ programozóvá tesz.
            A 2. feladatban megvalósított másoló konstruktor a mély másolást implementálja. Tehát a forrásként kapott LZW fát bejárjuk, és 
            minden elemének a másolatát elkészítjük a konstruálandó fában is. Ennek következtében lesz két külön fánk a meóriában, külön 
            gyökér és fa mutatóval. Binárisfa bejárások közül létezik preorder, postorder és inorder. Ezek közül bármelyiket használhatjuk, mindegyik a 
            megfelelő eredményhez vezet. A mi programunk a postorder bejárást alkalmazza, vagyis elsőnek dolgozzuk fel a gyemekeket, majd gyökeret.
            A mozgató konstruktor a többi konstruktorhoz megfelelően egy inicializálást hajt végre, a másoláshoz hasonlóan ez is egy másik 
            objektumra alapul. A különbség annyi, hogy a míg a másolásnál a másolásban részt vevő objektumok megmaradnak, addig a 
            mozgatásnál a forrás objektum megszűnik, pontosabban nem determináns állapotba kerül. A mozgató konstruktor arról ismerszik meg, hogy a 
            paramétere egy jobbérték referencia. A jobbérték refernciát a <![CDATA[&&]]> jelöli. Annak érdekében, hogy ez a konstruktor hívódjon meg, a 
           <function>std::move</function> függvényt kell meghívni. Gyakori tévedés, köszönhetően ennek a függvénynek a félreérthető nevének, hogy 
            mozgatást hajt végre. Valójában a paraméteréül kapott objektum jobbérték refernciájával tér vissza.
            Az LZWBinFa programunkban maga a mozgató konstruktor a mozgató értékadásra van alapozva. Az alap koncepció az, hogy az inicializálni kívánt 
            fa gyökerét null mutatóvá tesszük, majd megcseréljük a forrás és a cél fa gyökér mutatójának értékét, ezzel megvalósítva a mozgatást. Ezt
            úgy érjük el, hogy a mozgató konstruktoron keresztül meghívjuk a mozgató értékadást. Fontos látni, hogy mikor hívódik meg a konstruktor és mikor 
            az értékadás. Ha egy még nem inicializát objektumot szeretnénk másolással, mozgatással inicializálni, akkor a konstruktor hívódik. Ezzel szemben
            egy már inicializát objektumba szeretnénk másolni, mozgatni, akkor már az értékadás hajtódik végre. Ennek tudatában szerepel a 
            mozgató konstruktorban a következő sor:
            <programlisting language="c++">
                *this = std::move(forras);
            </programlisting>
            Szóval meghívódik a mozgató értékadás, ahol a pointer értékek cseréjét hajtjuk végre. Ehhez a <function>std::swap</function> függvényt 
            használjuk. Természetesen lehetne saját cserét is írni, ebben a könyvben több megoldást adtunk erre, de összességében elmondható, hogy
            érdemes a már előre implementált függvényeket, metódusokat használni. 
	    Összegezve a leírtakat, a másoló és mozgató szemantika a C++ nyelvben kiemelt szerepet játszik. Magabiztos használatuk elsajátítása nélkülözhetetlen a megbízható programok készítéséhez. 
        </para>
    </section> 

	
    <section>
	     <title>Hibásan implementált RSA törése</title>
	     <para>
		  Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló: https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71 73 fólia) által készített titkos szövegen.
	    </para>
	<para>
	    Az RSA egy kódolási módszer melyet 1976-ban implementáltak és amit a mai napig használnak. Használatához az USA-ban egészen 2000-ig díjat kellett fizetni. Az eljárás a maradékos osztásra alapszik, melynek során először választanunk kell nagy prímszámot, melyeket nevezzünk p és q-nak. Majd számoljuk ki N-et a p és q szorzatából, ez lesz a modulusa a két kulcsnak. Majd számoljuk ki f(N)=(p-1)*(q-1) értékét, ezek alapján meghatározzuk e értékét úgy hogy 1<e<f(N), illetve e és f(N) legnagyobb közös osztója 1, azaz relatív prímek. Ennek az e egész számnak a segítségével kódoljuk a szöveget az alábbi módon: c= m^e mod N, ahol m a kódolandó szöveg, mely ha betűkből áll először át kell konvertálnunk számmá. Az e értéke nyilvános kell hogy legyen gyakran használják egységésen a 65537-et, illetve az N értéke a kommunikáció tagjainak eltérő kell hogy legyen, ezek segítségével tudnak küldeni egy tagnak üzenetet, aki a saját d értékével megfejtheti. A d értékét a d*e=k*f(N)+1 egeyenlet segítségével határozzuk meg, ahol k pozitív egész. Így a d és N ismeretében visszakaphatjuk az eredeti szöveget, azaz m-et az alábbi módon m=c^d mod N.
	    Az RSA asszimetrikus kódolás mivel két kulcsa van, de a feladat megoldásához elég a nyilvános kulcsot meghaatroznunk, azaz az N értékét ha az e-t 65537-tel használjuk. Ez azért elegnedő mivel a kódolt üzenetet a hibás kódolás miatt feltörhetjük. A hibásan kódolás alatt azt értjük, hogy betünként kell lekódolnunk a szöveget, nem az egészet egybe, emiatt válik feltörhetővé a szöveg, mivel kódolásnál betűnként azonos szimbólumokat rendeltünk az egyes karakterekhez, így egy gyakorisági vizsgálatot elvégezve visszakaphatjuk az eredeti szöveget a titkos kulcs, azaz a d értékének ismerete nélkül. Ehhez szüskégünk lesz egy betű gyakorisági táblázatra lehetőleg az adott nyelvhez, ezt az alábbi linkről hasnzáltam fel: https://bs-gerillanyelveszet.blog.hu/2012/08/18/a_jellegzetesen_magyar_betuk_betukapcsolatok_es_hangjelolesek_vizsgalata.
	    A program elején static kulcsszóval definiáljuk a program során használt változókat, függvényeket, tömböket, ezek a program működéséig a memóriában lesznek. A freq függvény visszadja a már beolvasott betűgyakorisági táblázat leggyakoribb betűjét, majd ha találtunk leggyakoirbbat akkor töröljük a táblázatból. A leggyakoribb elem meghatározásához egy for ciklussal végigmegyünk a has tábla minden során, majd ha az adott sor értéke nagyobb mint az i változójé, akkor i-nek értékül adjuk az aktuális értéket és elmentjük a hozzátartozó kulcsértékét. Majd a main függvényben létrehozunk két nagy prímszámot, melyeknek meghatározzuk a szorzatát a multiply függvény segítségével és publickey nagy egész számot létrrehozzuk 65537 értékkel. Majd a try blokkban beolvassuk a parancssorban megadott kódolandó szöveget, ehhez ismernünk kell a szöveg szavainak számát, majd ezt for ciklussal menjük egy sztringbe parancssor argumentumonként szókösökkel elválasztva. Majd a megfelelő parancssori argumentumot felhasználva beolvassuk a megadott fájlból a betűgyakorisági táblázatot soronként egy hash táblázatba. Ehhez soronént létrehozunk egy String típusú tömböt, melynek elemeit egy tabulátor választja el, így az első sor betűjét mentjük egy változóba és a számát egésszámmá konvertálva egy másik változóba, majd ezeket a put függvénnyel mentjük egy hash táblába. Ezt a try blookot hibakezeljük a catch függvényben leírt módon, ha rossz parancssori argumentumokat adnánk meg. Majd a beolvasott szöveg betűit kisbetűkre állítjuk, majd byte típusú tömb segítségével kódoljuk a beolvasott szöveget kivéve a szóköz és pont karaktereket, vesszőt, pontosvesszőt, gondolatjelet, számokat jelen esetben. A többi betűkre végrehajtjuk az RSA kódolást, azaz vesszük a modulus-adik modolusát a publicKey értéknek. Majd kiirajtjuk az eredeti és kódolt sztringeket, majd a frequency hasmapba mentjük a beolvasott már kódolt szöveg egyes karaktereinek gyakoriságát úgy hogy mentjük az adott karakterhelyen szerplő karaktert egy értékkel, majd ha újra az fordul elő akkor növeljük az értékét eggyel a put, get, contains függvények segítségével. Majd a kódolt szöveg leggyakoribb betűjét kicseréljük a beolvasott táblázat leggyakoribb betűjével így megfelelő táblázat esetén visszakaphatjuk az eredeti szöveget, az egyes cserék után töröljük a mindkét tábla használt karakterének sorát. A freq függvényben új változót használtunk mivel anélkül végtelen ciklust kapnánk, mert módosítaná a while ciklust változóját is így mindkét cserélendő karakter egy betű lenne majd nulla, ezek viszont nem szerepelnek a kódolt szövegben.
	    Amint láthatjuk lekódolhatja az RSA számra, vagy akármilyen karakterre például "-ra is a szöveget, így a gyakorisági táblázatban szerepelni kell a magyar szövegkörnyezetben használt összes karaktereknek a hatékonyabb törés érdekében. 
	    A parancssoban megadhatjuk hogy a kódolandó szöveget fájlból akarjuk e beolvasni vagy parancssorból, célszerű többféle gyakorisági táblázatot is használni.
	    </para>
		<programlisting language="java"><![CDATA[
import java.io.BufferedReader;
import java.io.FileReader;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.util.HashMap;
import java.util.Map.Entry;

public class rsa {
	static int i;
	static char c;
	static HashMap<Character, Integer> charRank  = new HashMap<Character, Integer>();
	static String str = new String();
	static char freq(){
		char v = 0;
		i = 0;
		for(Entry<Character, Integer> e : charRank.entrySet()) {
			if (e.getValue() > i) {
				i = e.getValue();
				v = e.getKey();
			}
		}
		if (charRank.containsKey(v))
			charRank.remove(v);
		return v;
		}
	public static void main(String[] args) {
		i = 2100;
		
		SecureRandom random = new SecureRandom();
		
		BigInteger p = BigInteger.probablePrime(i/2, random);
		BigInteger q = BigInteger.probablePrime(i/2, random);
		
		BigInteger publicKey = new BigInteger("65537");
		BigInteger modulus = p.multiply(q);
		void usage(){
		System.out.println("Usage: java rsa táblázatelérésiútvonala 0/1 fájlnév/szöveg\n" + "ahol a betűgyakorisági-táblázat formája:\nbetű1\tgyakoriság1\nbetűn\tgyakoriságn\n" + "és 0 fájlból beolvasott szöveg/n" + "1 parancssorba beírt szöveg/n");
		}
		try {		
		if(args[1] == 1){
  		for(i = 2; i < argc; i++)
		str = str + ' ' + args[i];
		}
		if(args[1] == 0){
		FileReader fr = new FileReader(args[0]); 
    		while ((i=fr.read()) != -1)
 		str = (string) i + str;
		}
		else
		usage();
		BufferedReader reader = new BufferedReader(new FileReader(args[0]));
			String line;
			while((line = reader.readLine()) != null) {
				String[] arg = line.split("\t");
				c = arg[0].charAt(0);
				i = Integer.parseInt(arg[1]);
				charRank.put(c, i);
			}
		}catch (Exception e) {
			System.out.println(usage() + "Error-> " + e.getMessage());
		}
		
		str = str.toLowerCase();
		byte[] out = new byte[str.length()];
		for (i = 0; i < str.length(); i++) {
			c = str.charAt(i);
			if (c == ' ')
				out[i] = (byte)c;
			else
				out[i] = new BigInteger(new byte[]{(byte)c}).modPow(publicKey, modulus).byteValue();
		}

		System.out.println("Eredeti: " + str);
		String code = new String(out);
		System.out.println("Kódolt:" + code);

		HashMap<Character, Integer> frequency = new HashMap<Character, Integer>();
		for (i = 0; i < code.length(); i++) {
			 c = code.charAt(i);
			if (c != ' ')
				if(frequency.containsKey(c))
					frequency.put(c, frequency.get(c) + 1);
				else
					frequency.put(c, 1);
		}

		while (frequency.size() > 0) {
			i = 0;
			c = 0;
			for (Entry<Character, Integer> e : frequency.entrySet()) {
				if (i < e.getValue()) {
					i = e.getValue();
					c = e.getKey();
				}
			}
			code = code.replace(c, freq());
			frequency.remove(c);			
		}

		System.out.println("Visszafejtett: " + code);
						}
	}
]]>
</programlisting>
	<mediaobject>
		<imageobject>
		<imagedata fileref="rsa6.PNG" format="PNG" scale="65"/>
		</imageobject>
	</mediaobject>	    
	<mediaobject>
		<imageobject>
		<imagedata fileref="rsa4.PNG" format="PNG" scale="65"/>
		</imageobject>
	</mediaobject>
	<mediaobject>
	     <imageobject>
		<imagedata fileref="rsa5.PNG" format="PNG" scale="65"/>
	     </imageobject>
	</mediaobject>		
    </section>    
 
<section>
	     <title>Változó argumentumszámú ctor</title>
	     <para>
		Készítsünk olyan példát, amely egy képet tesz az alábbi projekt Perceptron osztályának bemenetére és a Perceptron ne egy értéket, hanem egy ugyanakkora méretű képet ” adjon vissza. (Lásd még a 4 hét/Perceptron osztály feladatot is.)	    </para>
	<para>
		A Perceptron osztály konstruktora változó argumentumszámú konstruktor melynek működését már korábbi Perceptronos feladatban leírtam, röviden annyit jelent hogy akárhány értékszámú konstruktorral használhatjuk az osztályt csak az első elem mindig a rajta kívüli elemek számát jelenti. Ennek elemszáma adja meg a neurális háló rétegeinek számát, eddigi feladatainkban egyrétegűt használtunk ugye bemeneti és kimeneti réteggel. A jelen feladatban az előző feladathoz képest módosításokat kell végeznünk, mivel most nem egy számot akarunk kapni, hanem egy ugyanakkorra méretű képet.
		Először is módosítanunk kell az mlp.hpp header fájl operátor túlterhelő függvényét, mivel ezzel végezzük a számításokat és határozzuk meg a végeredményt, ami most nem egy szám, hanem egy tömb lesz. Így mödosítanunk kell a visszatérési értéket double* -ra mivel így a visszatérési érték egy double típúsu tömb memóriacíme lesz. Illetve a paraméterül kapott double típúsu image tömbbe mentjük a kiszámolt értékeket, mivel ugyanannyi elemű lesz a bemenet mint a kimenet, hogy azonos képet kapjunk. 
		<programlisting language="C++"><![CDATA[		
		 double* operator() ( double image [] )
                 {
		...
		for(int i = 0; i < n_units[n_layers - 1]; i++)
      		image[i] = units[n_layers - 1][i];
    		return image;
  		}
]]>
</programlisting>
		Majd a main.cpp programot is módosítanunk kell, hogy a Perceptron osztály konstruktorának a kimeneti rétegének értéke ugye size legyen, azaz képmértetnyi. Majd a kiszámolt értéket tároló value változó típusát módosítanunk kell double*-ra mivel az mlp.hpp-ben a kiszámolt értékeket double* típusú tömbjének címét kapjuk vissza a () operátort használva. Majd két egymásba ágyazott for ciklussal módosítjuk a beolvasott png kép rgb színkódjának a red érétékeit a Perceptron által kiszámítottakra, melyet ugye az eredeti red értékekből számítottunk ki. Majd a write függvényt meghívjuk a beolvasott képre újkép.png paraméterrel, így mentjük a módosított képet újkép.png néven.
		<programlisting language="C++"><![CDATA[
		
]]>
</programlisting>
	</para>	
	<mediaobject>
		<imageobject>
		<imagedata fileref="vált1.PNG" format="PNG" scale="65"/>
		</imageobject>
	</mediaobject>
	<mediaobject>
	     <imageobject>
		<imagedata fileref="vált2.PNG" format="PNG" scale="65"/>
	     </imageobject>
	</mediaobject>	
	</section>	
	
	
</chapter>	    
