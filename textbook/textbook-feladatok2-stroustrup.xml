<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Stroustrup!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>JDK osztályok</title>
     <para>
          Írjunk olyan Boost C++ programot (indulj ki például a fénykardból) amely kilistázza a JDK összes osztályát (miután kicsomagoltuk az src.zip állományt, arra ráengedve)!
     </para>
     <para>
          A feladat megoldásához először is telepíteni kell a JDK osztályokat a gépünkre. A JDK állományok benne vannak például az openjdk-13 csomagban, amit letöltehetünk akár a java.net weboldalról a wget parancssori kifejezés használatával, melyet szükség esetén telepíthetünk a sudo apt-get install parancs segítségével a parancsossorban. Miután letöltöttük az állományt láthatjuk hogy tar kiterjesztése van. tehát egy tömörített fájl melyet a tar parancssori kifejezéssel kicsomagolhatunk a megfelelő kapcsolók használatával. Az xzvf kapcsolót használtam, melyben az x és z a lényegesebbek hogy kicsomagoljon és a gzip segítségégvel, a v kapcsolóval a folyamat végrehajtódását követhetjük nyomon a terminálban, az f kapcsolóval pedig engedélyezzük a névadást a létrejövő fájlnak, ami alapértelmezetten, ahogy csináltam megegyezik a tömörített fájl nevével. De ez nem fontos mivel mi az src.zip fájllal fogunk dolgozni, ami mivel zip kiterjesztésű így ez is egy tömtörített fájl csak más programot használunk a kicsomagolásához, ahogy a tömörítéshez is használtak. Az unzip csomagot hasznáéjuk a kitömörítéshez, de előtte a könyebb elérés érdekében, amit ugye az általunk írt program szükséges, a move kifejezéssel a jdk-s könyvtárból az általunk létrehozott gyökérkönyvtárba, amit ehhez a feladathoz hoztunk létre, ahova letöltöttük a fájlt és amibe dolgozunk áthelyeztem az src.zip fájlt. Ebbe a mappába a parancssorban eljuthatunk a cd parancsokkal, de egyszerűbb jobb klikkel a Megnyitás parancssorban utasítást használni. Az áthelyezéskor . karakter jelentése az aktuális könyvtár, azaz az általunk létrehozott gyökérkönyvtár. Illetve a helyes működéshez a már nem szükséges fájlokat törölhetjük az src parancssori kifejezés segítségével, az r és v kapcsolót használtam mivel a mappát almappáival együtt törlöm és láthatjuk hogy halad a folyamat, ehhez telepítenünk kell a secure-delete csomagot az apt install segítségével: 
          tar https://download.java.net/java/GA/jdk13/5b8a42f3905b406298b72d750b6919f6/33/GPL/openjdk-13_linux-x64_bin.tar.gz
          mv jdk-13/lib/src.zip .
          unzip src.zip
          apt get install secure-delete
          srm -rv jdk-13 src.zip openjdk-13_linux-x64_bin.tar.gz
          A feladat alapján boost C++ programot kell írnunk, ehhez azonban telepíteni kell a boost könyvtárakat, amiket tartalmaz például a libboost-all-dev csomag, amit a már általunk ismert apt-get install parancsori kifejezéssel tehetjük meg az alábbi módon:
          sudo apt-get install libboost-all-dev
          A programunkat a g++ fordítóval fordítjuk használva az alaábbi kapcsolókat:
          g++ program.cpp -o bejaro -lboost_system -lboost_filesystem -lboost_program_options -o p
          A program futtatása az általunk elnevezett névvel történik amit a fordításkor adtunk meg az o kapcsolóval , majd második paraméterként meg kell adnunk a /home könytvártól a létrehozott mappánk elérési útvobalát az alábbi módon:
          ./p /home/attila/Letöltések/jdk
          Ezt a programunk elején hibakezeltem is egy parancssori argumentumainak számának ellenőrző feltétellel. Ha teljesül akkor kapunk egy hibaüzenetet a program használatáról, ha nem akkor példányozzuk az src mappa könyvtárrendszerét, melyre meghívjuk az általunk megírt read_files függvényt ami végigmegy a könyvtárszerkezet mappáin és a return_vec nevű vektorba menti a java kiterjesztésű fájlokat melynek értékét értékül adjuk a paths vektornak. Így az src mappának a java kiterjesztésű fájlainak neveit tartalmazza a paths vektor, melynek elemein az auto &path :paths kifejezés segítségével, majd a fájlok tartalmainak eléréséhez használjuk az ifstream kifejezést, illetve a getline függvénnyel az adott fájl sorain megyünk végig egy végtelen ciklussal, amíg nem találjuk meg a fájl nevét egy class kifejezés mögött. Ha megtaláltuk a keresett sztringet az adott fájl valamely sorában akkor kiiratjuk a szabványos kimenetre a fájl elérési útvonalát zárójelben, illetve a zárójel előtt az adott JDK osztály nevét és növeljük az n változó értékét eggyel,  mivel megszámoljuk a JDK osztályainak számát. A keresést az if(l.find(findstr) != std::string::npos) kifejezéssel végeztük ami akkor lesz igaz ha a find paramétreként megadott objektum legalább egyszer szerepel a find által meghívott objektumban.  A break kifejezéssel tudunk kilépni a végtelen while ciklusból ha megtaláltuk a keresett kifejezést. A c_str függvényt akkor használjuk, ha egy adott objektumra egy C függvényt hívunk meg, ami C típusó sztringet vár paraméterül, így meghívjuk rá a c_str függvényt a helyes működés érdekében. A stem függvény segítségével kapjuk meg a JDK osztályok neveit a fájnevükből, melyek java kiterjesztésűek és tartalmazzák a fájlenevet főosztályként.
      </para>
      <programlisting language = "C++"><![CDATA[
#include <iostream>
#include <string>
#include <fstream>
#include <vector>
#include <boost/filesystem.hpp>
#include <boost/filesystem/fstream.hpp>

std::vector<boost::filesystem::path> return_vec;
std::vector<boost::filesystem::path>
read_files(const boost::filesystem::path path) {
    if (is_regular_file(path)) {
        std::string ext(".java");	// We only care about .java files
        if ( ! ext.compare(boost::filesystem::extension(path))) {
            return_vec.push_back(path);
        }
    } else if (is_directory(path)) {
        for (boost::filesystem::directory_entry & entry
                :
                boost::filesystem::directory_iterator(path)) {
            read_files(entry.path());
        }
    }
    return return_vec;
}
int
main(int argc, char **argv) {
    if(argc!=2){
    std::cout << "Usage: ./<filename> <path>" << std:endl;
    return -1;
    }
    else{
    boost::filesystem::path sources_path { argv[1] };
    std::vector<boost::filesystem::path> paths = read_files(sources_path);
    std::string l;
    int n = 0;
    for (auto const &path : paths) {
        std::ifstream in(path.c_str());
        if (in) {
            while (std::getline(in, l)) {
                std::string find_str = "class " + path.stem().string();
                if (l.find(find_str) != std::string::npos) {
                    std::cout
                        << path.stem().c_str()
                        << " (file: " << path << ")"
                        << std::endl;
                    n++;
                    break;
                }
            }
        }
    }
    std::cout
        << "There are "
        << n
        << " classes in JDK (sources dir: " << sources_path << ")."
        << std::endl;
    return 0;
}
}
           ]]>
        </programlisting>
      	   <mediaobject>
            <imageobject>
                <imagedata fileref="jdk1.png"></imagedata>
            </imageobject>
        </mediaobject>
	    	   <mediaobject>
            <imageobject>
                <imagedata fileref="jdk.png"></imagedata>
            </imageobject>
        </mediaobject>
     </section>
    
    <section>
	     <title>Másoló-mozgató szemantika</title>
	     <para>
              Kódcsipeteken (copy és move ctor és assign) keresztül vesd össze a C++11 másoló és a mozgató szemantikáját, a mozgató konstruktort alapozd a mozgató értékadásra! 
        </para>    
        <para>
             A konstruktorok segítségével példányosítjuk az osztályokat, kezdőértéket adunk nekik ezzel létrehozzuk az objektumokat. A konstruktor nevének meg kell egyeznie annak az osztálynak a nevével amelyikre meghívtuk, a létrehozott objektumok által lefoglalt tárterületet a destruktorok segítségével szabadítjuk fel, melynek a neve megeyezik az osztályéval és ~ jel van előtte. 
	     Ha a konstruktorok paraméterének objektumokat adunk meg akkor meghívódik a másoló konstruktor, ami létrehozza létrehoz egy új objektumot a paraméterként megadott azonos osztálybeli objektum értékéivel: 
		osztály(const osztály& paraméter){
		size_t size = strlen(paraméter.adat);
		data = new char[size-1];
		memcpy(adat, paraméter.adat, size);
		}
	     Ez a kódcsipet hívódik meg ha egy osztály típusú objektumot próbálunk létrehozni egy másik osztály típusú objektum segítségével, annak értékeievel. A konstruktort úgy definiáltuk hogy megnézi a másolandó objektum változójának méretét, majd lefoglal annyi méretet az aktuális objektum ugyanazon nevű változójába, majd a memcpy függvénnyel átmásoljuk a paraméter objektum adott heap memória tartalmát amit a változó névvel azonosítunk a hozzátartozó aktuális objektumba. A new kifejezéssel heapen lefoglalt memóriát a delte függvénnyel nekünk kellessz törölni, jelen esetben delete data[] mivel memóriatömbről van szó.
	     A másoló értékadás akkor hívódik meg ha két már létező azonos osztálybeli objektum közt egyenlőség jel van, ekkor nyilván a baloldali objektumnak akarjuk értékül adni a jobb oldali objektumot. Ehhez túlterheltük az egyenlőségjel operátort:
		osztály& operator=osztály(const osztály& paraméter){
		size_t size = strlen(const paraméter.adat);
		data = new char[size-1];
		memcpy(adat, paraméter.adat, size);
		return *this
		}
	     Itt is hasonló művelet hajtódik végre mint a másoló konstruktornál, de ennek a konstruktornak lesz visszatérési értéke mégpedig a dereferenciált this kifejezés, ami az aktuális objektum memóriacíme, *-gal viszont maga az objektum.
	     Amint láthatjuk mindkét esetben megmaradt az eredeti objektum heapen foglalt területe és emellé hoztunk létre egy újat ugyanazon értékekekkel. Azonban ha nincs szükségünk már az eredeti objektumunk egyes részeire és ezeket egy másik hasonló osztálybeli objektumban akarjuk tovább használni akkor hasznos a C++11 által bevezetett mozgató szemantikák, azaz a mozgató konstruktor és mozgató értékadás. Ezek akkor hívódnak meg ha a konstruktor objektuma jobbérték típusú kell hogy legyen, mivel ha alapértelmezettként balérték típusú akkor a másolószemntika hívódna meg. Ezek definiálásakor &&-et használunk referenciának:
		osztály (osztály&& paraméter ){
		adat = paraméter.adat;
		paraméter.adat = nullptr;
		}
	     Amint láthatjuk a mozgató konstruktor esetén, ami akkor hívódik meg ha létrehakarunk hozni jobbérték objektumból vele azonos osztálybeli objektumot, az átmozgatni kívánt változó memóriacímét értékül adtuk az aktuális objektuméhoz tartozó változónak, majd az eredeti objektuménak nullptr értéket adtunk, így töröltük. Mivel törlés nélkül probléma lett volna a memóriafelszabadításkor is mivel két változó is ugyanarra a memóriacímre mutatott és C++ ezeket nekünk kell törölni és a duplatörlés memóriaszivárágst eredményezhet. Egyébként Java nyelvben az objektumoknak csak a nevét kell módosítani, azaz több objektum használhatja ugyanazt a memóriacímet így ha módosul az egyik, vele módosul a másik, azonban itt a memóriafelszabadítás automatikusan végződik a garbage collapter segítségével.
	     A mozgató értékadás akkor hívódik meg ha egynelőség jelet használunk két azonos típósó objektum között, melynek jobb oldalán jobbértékű, baloldalán balértékű objektum szerepel:
		osztály& operator=osztály(const osztály&& paraméter){
		swap(adat,paraméter.adat);
		return *this;
		}
	     Ez is hasonló szemantikájú a másoló konstruktorhoz annyiban hogy az egyenlőség jel operátort terheljük túl benne, azaz átdefiniáljuk a működését az alapértelmezettől eltérő módon. Itt a swap függvény segítségével felcseréljük az átadni kívánt változók értékeit, így egymás már egymás memóriacímeire fognak mutatni, itt az adat alapértelmezettként nullptr.	
	     A feladat alapján a mozgató konstruktorunkat alapoznunk kell a mozgató értékadásra:
		osztály (osztály&& paraméter ){
		adat = nullptr;
		*this = move(paraméter);
		}
		osztály& operator=osztály(const osztály&& paraméter){
		swap(adat, paraméter.adat);
		return *this
		}
	      Ez ugye akkor hívódik meg amikor a mozgató konstruktorba ágyazzuk a mozgató értékadást és hasonlóképpen működik a mozgató konstruktorhoz. Először is nullptr értéket adjuk az aktuális objektum adat változójának, aminek az értékét ugye felakarjuk cserélni a paraméterként adott objektuméval, ehhez segítségül hívjuk a mozgató értékadást amiben ugyanis értelmezett a swap függvény. Ahhoz hogy meghívjuk a move függvénnyel jobbértékűre kell állítanunk a paraméter objektum típusát baloldaliról, így egyenlővé téve az aktuális objektumunkkal. Ezzel teljesül a feltétetele a mozgató értékadásnak és meg is hívódik, ami azt eredményezi hogy a mozgató értékadás által megfelően módosított objektumot értékül adjuk a mozgató konstruktor aktuális objektumának. 
	    </para>
	</section>
	
    <section>
	     <title>Hibásan implementált RSA törése</title>
	     <para>
		  Készítsünk betű gyakoriság alapú törést egy hibásan implementált RSA kódoló: https://arato.inf.unideb.hu/batfai.norbert/UDPROG/deprecated/Prog2_3.pdf (71 73 fólia) által készített titkos szövegen.
	    </para>
	    <para>
		    
	    </para>	    
        
        
        
