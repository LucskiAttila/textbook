<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:xi="http://www.w3.org/2001/XInclude" version="5.0" xml:lang="hu">
    <info>
        <title>Helló, Conway!</title>
        <keywordset>
            <keyword/>
        </keywordset>
    </info>
    <section>
        <title>Hangyaszimulációk</title>
        <para>
            Írj Qt C++-ban egy hangyaszimulációs programot, a forrásaidról utólag reverse engineering jelleggel
            készíts UML osztálydiagramot is!
        </para>
	<programlisting language="C++">
                <![CDATA[
//main.cpp
#include <QApplication>
#include <QDesktopWidget>
#include <QDebug>
#include <QDateTime>
#include <QCommandLineOption>
#include <QCommandLineParser>

#include "antwin.h"

/*
 * 
 * ./myrmecologist -w 250 -m 150 -n 400 -t 10 -p 5 -f 80 -d 0 -a 255 -i 3 -s 3  -c 22
 *
 */

int main ( int argc, char *argv[] )
{

    QApplication a ( argc, argv );

    QCommandLineOption szeles_opt ( {"w","szelesseg"}, "Oszlopok (cellakban) szama.", "szelesseg", "200" );
    QCommandLineOption magas_opt ( {"m","magassag"}, "Sorok (cellakban) szama.", "magassag", "150" );
    QCommandLineOption hangyaszam_opt ( {"n","hangyaszam"}, "Hangyak szama.", "hangyaszam", "100" );
    QCommandLineOption sebesseg_opt ( {"t","sebesseg"}, "2 lepes kozotti ido (millisec-ben).", "sebesseg", "100" );
    QCommandLineOption parolgas_opt ( {"p","parolgas"}, "A parolgas erteke.", "parolgas", "8" );
    QCommandLineOption feromon_opt ( {"f","feromon"}, "A hagyott nyom erteke.", "feromon", "11" );
    QCommandLineOption szomszed_opt ( {"s","szomszed"}, "A hagyott nyom erteke a szomszedokban.", "szomszed", "3" );
    QCommandLineOption alapertek_opt ( {"d","alapertek"}, "Indulo ertek a cellakban.", "alapertek", "1" );
    QCommandLineOption maxcella_opt ( {"a","maxcella"}, "Cella max erteke.", "maxcella", "50" );
    QCommandLineOption mincella_opt ( {"i","mincella"}, "Cella min erteke.", "mincella", "2" );
    QCommandLineOption cellamerete_opt ( {"c","cellameret"}, "Hany hangya fer egy cellaba.", "cellameret", "4" );
    QCommandLineParser parser;

    parser.addHelpOption();
    parser.addVersionOption();
    parser.addOption ( szeles_opt );
    parser.addOption ( magas_opt );
    parser.addOption ( hangyaszam_opt );
    parser.addOption ( sebesseg_opt );
    parser.addOption ( parolgas_opt );
    parser.addOption ( feromon_opt );
    parser.addOption ( szomszed_opt );
    parser.addOption ( alapertek_opt );
    parser.addOption ( maxcella_opt );
    parser.addOption ( mincella_opt );
    parser.addOption ( cellamerete_opt );

    parser.process ( a );

    QString szeles = parser.value ( szeles_opt );
    QString magas = parser.value ( magas_opt );
    QString n = parser.value ( hangyaszam_opt );
    QString t = parser.value ( sebesseg_opt );
    QString parolgas = parser.value ( parolgas_opt );
    QString feromon = parser.value ( feromon_opt );
    QString szomszed = parser.value ( szomszed_opt );
    QString alapertek = parser.value ( alapertek_opt );
    QString maxcella = parser.value ( maxcella_opt );
    QString mincella = parser.value ( mincella_opt );
    QString cellameret = parser.value ( cellamerete_opt );

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    AntWin w ( szeles.toInt(), magas.toInt(), t.toInt(), n.toInt(), feromon.toInt(), szomszed.toInt(), parolgas.toInt(),
                  alapertek.toInt(), mincella.toInt(), maxcella.toInt(),
                  cellameret.toInt() );

    w.show();

    return a.exec();
}
	]]>
</programlisting> 

	<programlisting language="C++">
                <![CDATA[
//antwin.h
#ifndef ANTWIN_H
#define ANTWIN_H

#include <QMainWindow>
#include <QPainter>
#include <QString>
#include <QCloseEvent>
#include "antthread.h"
#include "ant.h"

class AntWin : public QMainWindow
{
    Q_OBJECT

public:
    AntWin(int width = 100, int height = 75,
           int delay = 120, int numAnts = 100,
           int pheromone = 10, int nbhPheromon = 3,
           int evaporation = 2, int cellDef = 1,
           int min = 2, int max = 50,
           int cellAntMax = 4, QWidget *parent = 0);

    AntThread* antThread;

    void closeEvent ( QCloseEvent *event ) {

        antThread->finish();
        antThread->wait();
        event->accept();
    }

    void keyPressEvent ( QKeyEvent *event )
    {

        if ( event->key() == Qt::Key_P ) {
            antThread->pause();
        } else if ( event->key() == Qt::Key_Q
                    ||  event->key() == Qt::Key_Escape ) {
            close();
        }

    }

    virtual ~AntWin();
    void paintEvent(QPaintEvent*);

private:

    int ***grids;
    int **grid;
    int gridIdx;
    int cellWidth;
    int cellHeight;
    int width;
    int height;
    int max;
    int min;
    Ants* ants;

public slots :
    void step ( const int &);

};

#endif
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//antthread.h
#ifndef ANTTHREAD_H
#define ANTTHREAD_H

#include <QThread>
#include "ant.h"

class AntThread : public QThread
{
    Q_OBJECT

public:
    AntThread(Ants * ants, int ***grids, int width, int height,
             int delay, int numAnts, int pheromone, int nbrPheromone, 
             int evaporation, int min, int max, int cellAntMax);
    
    ~AntThread();
    
    void run();
    void finish()
    {
        running = false;
    }

    void pause()
    {
        paused = !paused;
    }

    bool isRunnung()
    {
        return running;
    }

private:
    bool running {true};
    bool paused {false};
    Ants* ants;
    int** numAntsinCells;
    int min, max;
    int cellAntMax;
    int pheromone;
    int evaporation;
    int nbrPheromone;
    int ***grids;
    int width;
    int height;
    int gridIdx;
    int delay;
    
    void timeDevel();

    int newDir(int sor, int oszlop, int vsor, int voszlop);
    void detDirs(int irany, int& ifrom, int& ito, int& jfrom, int& jto );
    int moveAnts(int **grid, int row, int col, int& retrow, int& retcol, int);
    double sumNbhs(int **grid, int row, int col, int);
    void setPheromone(int **grid, int row, int col);

signals:
    void step ( const int &);

};

#endif
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//ant.h
#ifndef ANT_H
#define ANT_H

class Ant
{

public:
    int x;
    int y;
    int dir;

    Ant(int x, int y): x(x), y(y) {
        
        dir = qrand() % 8;
        
    }

};

typedef std::vector<Ant> Ants;

#endif
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//antwin.cpp
#include "antwin.h"
#include <QDebug>

AntWin::AntWin ( int width, int height, int delay, int numAnts,
                 int pheromone, int nbhPheromon, int evaporation, int cellDef,
                 int min, int max, int cellAntMax, QWidget *parent ) : QMainWindow ( parent )
{
    setWindowTitle ( "Ant Simulation" );

    this->width = width;
    this->height = height;
    this->max = max;
    this->min = min;

    cellWidth = 6;
    cellHeight = 6;

    setFixedSize ( QSize ( width*cellWidth, height*cellHeight ) );

    grids = new int**[2];
    grids[0] = new int*[height];
    for ( int i=0; i<height; ++i ) {
        grids[0][i] = new int [width];
    }
    grids[1] = new int*[height];
    for ( int i=0; i<height; ++i ) {
        grids[1][i] = new int [width];
    }

    gridIdx = 0;
    grid = grids[gridIdx];

    for ( int i=0; i<height; ++i )
        for ( int j=0; j<width; ++j ) {
            grid[i][j] = cellDef;
        }

    ants = new Ants();

    antThread = new AntThread ( ants, grids, width, height, delay, numAnts, pheromone,
                                nbhPheromon, evaporation, min, max, cellAntMax);

    connect ( antThread, SIGNAL ( step ( int) ),
              this, SLOT ( step ( int) ) );

    antThread->start();

}

void AntWin::paintEvent ( QPaintEvent* )
{
    QPainter qpainter ( this );

    grid = grids[gridIdx];

    for ( int i=0; i<height; ++i ) {
        for ( int j=0; j<width; ++j ) {

            double rel = 255.0/max;

            qpainter.fillRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight,
                                QColor ( 255 - grid[i][j]*rel,
                                         255,
                                         255 - grid[i][j]*rel) );

            if ( grid[i][j] != min )
            {
                qpainter.setPen (
                    QPen (
                        QColor ( 255 - grid[i][j]*rel,
                                 255 - grid[i][j]*rel, 255),
                        1 )
                );

                qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                    cellWidth, cellHeight );
            }



            qpainter.setPen (
                QPen (
                    QColor (0,0,0 ),
                    1 )
            );

            qpainter.drawRect ( j*cellWidth, i*cellHeight,
                                cellWidth, cellHeight );

        }
    }

    for ( auto h: *ants) {
        qpainter.setPen ( QPen ( Qt::black, 1 ) );

        qpainter.drawRect ( h.x*cellWidth+1, h.y*cellHeight+1,
                            cellWidth-2, cellHeight-2 );

    }

    qpainter.end();
}

AntWin::~AntWin()
{
    delete antThread;

    for ( int i=0; i<height; ++i ) {
        delete[] grids[0][i];
        delete[] grids[1][i];
    }

    delete[] grids[0];
    delete[] grids[1];
    delete[] grids;

    delete ants;
}

void AntWin::step ( const int &gridIdx )
{

    this->gridIdx = gridIdx;
    update();
}
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//antThread.cpp
AntThread::AntThread ( Ants* ants, int*** grids,
                     int width, int height,
                     int delay, int numAnts, 
                     int pheromone, int nbrPheromone, 
                     int evaporation,
                     int min, int max, int cellAntMax)
{
    this->ants = ants;
    this->grids = grids;
    this->width = width;
    this->height = height;
    this->delay = delay;
    this->pheromone = pheromone;
    this->evaporation = evaporation;
    this->min = min;
    this->max = max;
    this->cellAntMax = cellAntMax;
    this->nbrPheromone = nbrPheromone;

    numAntsinCells = new int*[height];
    for ( int i=0; i<height; ++i ) {
        numAntsinCells[i] = new int [width];
    }

    for ( int i=0; i<height; ++i )
        for ( int j=0; j<width; ++j ) {
            numAntsinCells[i][j] = 0;
        }

    qsrand ( QDateTime::currentMSecsSinceEpoch() );

    Ant h {0, 0};
    for ( int i {0}; i<numAnts; ++i ) {

        h.y = height/2 + qrand() % 40-20;
        h.x = width/2 + qrand() % 40-20;

        ++numAntsinCells[h.y][h.x];

        ants->push_back ( h );

    }

    gridIdx = 0;
}

double AntThread::sumNbhs ( int **grid, int row, int col, int dir )
{
    double sum = 0.0;

    int ifrom, ito;
    int jfrom, jto;

    detDirs ( dir, ifrom, ito, jfrom, jto );

    for ( int i=ifrom; i<ito; ++i )
        for ( int j=jfrom; j<jto; ++j )

            if ( ! ( ( i==0 ) && ( j==0 ) ) ) {
                int o = col + j;
                if ( o < 0 ) {
                    o = width-1;
                } else if ( o >= width ) {
                    o = 0;
                }

                int s = row + i;
                if ( s < 0 ) {
                    s = height-1;
                } else if ( s >= height ) {
                    s = 0;
                }

                sum += (grid[s][o]+1)*(grid[s][o]+1)*(grid[s][o]+1);

            }

    return sum;
}

int AntThread::newDir ( int sor, int oszlop, int vsor, int voszlop )
{

    if ( vsor == 0 && sor == height -1 ) {
        if ( voszlop < oszlop ) {
            return 5;
        } else if ( voszlop > oszlop ) {
            return 3;
        } else {
            return 4;
        }
    } else if ( vsor == height - 1 && sor == 0 ) {
        if ( voszlop < oszlop ) {
            return 7;
        } else if ( voszlop > oszlop ) {
            return 1;
        } else {
            return 0;
        }
    } else if ( voszlop == 0 && oszlop == width - 1 ) {
        if ( vsor < sor ) {
            return 1;
        } else if ( vsor > sor ) {
            return 3;
        } else {
            return 2;
        }
    } else if ( voszlop == width && oszlop == 0 ) {
        if ( vsor < sor ) {
            return 7;
        } else if ( vsor > sor ) {
            return 5;
        } else {
            return 6;
        }
    } else if ( vsor < sor && voszlop < oszlop ) {
        return 7;
    } else if ( vsor < sor && voszlop == oszlop ) {
        return 0;
    } else if ( vsor < sor && voszlop > oszlop ) {
        return 1;
    }

    else if ( vsor > sor && voszlop < oszlop ) {
        return 5;
    } else if ( vsor > sor && voszlop == oszlop ) {
        return 4;
    } else if ( vsor > sor && voszlop > oszlop ) {
        return 3;
    }

    else if ( vsor == sor && voszlop < oszlop ) {
        return 6;
    } else if ( vsor == sor && voszlop > oszlop ) {
        return 2;
    }

    else { //(vsor == sor && voszlop == oszlop)
        qDebug() << "ZAVAR AZ EROBEN az iranynal";

        return -1;
    }

}

void AntThread::detDirs ( int dir, int& ifrom, int& ito, int& jfrom, int& jto )
{

    switch ( dir ) {
    case 0:
        ifrom = -1;
        ito = 0;
        jfrom = -1;
        jto = 2;
        break;
    case 1:
        ifrom = -1;
        ito = 1;
        jfrom = 0;
        jto = 2;
        break;
    case 2:
        ifrom = -1;
        ito = 2;
        jfrom = 1;
        jto = 2;
        break;
    case 3:
        ifrom =
            0;
        ito = 2;
        jfrom = 0;
        jto = 2;
        break;
    case 4:
        ifrom = 1;
        ito = 2;
        jfrom = -1;
        jto = 2;
        break;
    case 5:
        ifrom = 0;
        ito = 2;
        jfrom = -1;
        jto = 1;
        break;
    case 6:
        ifrom = -1;
        ito = 2;
        jfrom = -1;
        jto = 0;
        break;
    case 7:
        ifrom = -1;
        ito = 1;
        jfrom = -1;
        jto = 1;
        break;

    }

}

int AntThread::moveAnts ( int **racs,
                           int sor, int oszlop,
                           int& vsor, int& voszlop, int dir )
{

    int y = sor;
    int x = oszlop;

    int ifrom, ito;
    int jfrom, jto;

    detDirs ( dir, ifrom, ito, jfrom, jto );

    double osszes = sumNbhs ( racs, sor, oszlop, dir );
    double random = ( double ) ( qrand() %1000000 ) / ( double ) 1000000.0;
    double gvalseg = 0.0;


    for ( int i=ifrom; i<ito; ++i )
        for ( int j=jfrom; j<jto; ++j )
            if ( ! ( ( i==0 ) && ( j==0 ) ) )
            {
                int o = oszlop + j;
                if ( o < 0 ) {
                    o = width-1;
                } else if ( o >= width ) {
                    o = 0;
                }

                int s = sor + i;
                if ( s < 0 ) {
                    s = height-1;
                } else if ( s >= height ) {
                    s = 0;
                }

                //double kedvezo = std::sqrt((double)(racs[s][o]+2));//(racs[s][o]+2)*(racs[s][o]+2);
                //double kedvezo = (racs[s][o]+b)*(racs[s][o]+b);
                //double kedvezo = ( racs[s][o]+1 );
                double kedvezo = (racs[s][o]+1)*(racs[s][o]+1)*(racs[s][o]+1);

                double valseg = kedvezo/osszes;
                gvalseg += valseg;

                if ( gvalseg >= random ) {

                    vsor = s;
                    voszlop = o;

                    return newDir ( sor, oszlop, vsor, voszlop );

                }

            }

    qDebug() << "ZAVAR AZ EROBEN a lepesnel";
    vsor = y;
    voszlop = x;

    return dir;
}

void AntThread::timeDevel()
{

    int **racsElotte = grids[gridIdx];
    int **racsUtana = grids[ ( gridIdx+1 ) %2];

    for ( int i=0; i<height; ++i )
        for ( int j=0; j<width; ++j ) 
        {
            racsUtana[i][j] = racsElotte[i][j];

            if ( racsUtana[i][j] - evaporation >= 0 ) {
                racsUtana[i][j] -= evaporation;
            } else {
                racsUtana[i][j] = 0;
            }

        }

    for ( Ant &h: *ants ) 
    {

        int sor {-1}, oszlop {-1};
        int ujirany = moveAnts( racsElotte, h.y, h.x, sor, oszlop, h.dir );

        setPheromone ( racsUtana, h.y, h.x );

        if ( numAntsinCells[sor][oszlop] <cellAntMax ) {

            --numAntsinCells[h.y][h.x];
            ++numAntsinCells[sor][oszlop];

            h.x = oszlop;
            h.y = sor;
            h.dir = ujirany;
            
        }
    }

    gridIdx = ( gridIdx+1 ) %2;
}



void AntThread::setPheromone ( int **racs,
                         int sor, int oszlop )
{

    for ( int i=-1; i<2; ++i )
        for ( int j=-1; j<2; ++j )    
            if ( ! ( ( i==0 ) && ( j==0 ) ) ) 
            {
                int o = oszlop + j;
                {
                    if ( o < 0 ) {
                        o = width-1;
                    } else if ( o >= width ) {
                        o = 0;
                    }
                }
                int s = sor + i;
                {
                    if ( s < 0 ) {
                        s = height-1;
                    } else if ( s >= height ) {
                        s = 0;
                    }
                }

                if ( racs[s][o] + nbrPheromone <= max ) {
                    racs[s][o] += nbrPheromone;
                } else {
                    racs[s][o] = max;
                }


            }

    if ( racs[sor][oszlop] + pheromone <= max ) {
        racs[sor][oszlop] += pheromone;
    } else {
        racs[sor][oszlop]  = max;
    }

}

void AntThread::run()
{
    running = true;
    while ( running ) {

        QThread::msleep ( delay );

        if ( !paused ) {
            timeDevel();
        }

        emit step ( gridIdx );

    }

}

AntThread::~AntThread()
{
    for ( int i=0; i<height; ++i ) {
        delete [] numAntsinCells[i];
    }

    delete [] numAntsinCells;
}
	]]>
</programlisting>
	<para>
	A main.cpp fajlban letrehozunk egy QApplication osztalybeli objektumot a neven, mellyel a parancssori objektumokat kezeljuk. A QCommandLineOption x kosntruktor segitsegevel letrehozunk egy x nevu kapcsolot, az elso parameterei a kapcsolo nevei a parancssorban, a masodik a leiras a kapcsolohoz tartozo leiras ami egy mondat, a harmadik az ertek neve, a negyedik az alapertek. A QCommandLineParser parser; paranccsal letrehozunk egy parser nevu objektumot a QCommandLineParser osztalyhoz. A parser.addHelpOption(); paranccsal definialunk a parser objektumhoz egy -h segitseg kapcsolot, a parser.addVersionOption(); fuggveny pedig a verziojat adja meg az applikacionak, kapcsoloja a -v. A parser.addOption fuggvenynek parameterul adunk egy kapcsolot nevet amit az elemzes alatt keres. A parser.process ( a ); paranccsal beallitjuk hogy a parancssor a QApplication a objektumabol szarmazzon. A QString x paranccsal letrehozunk egy x nevu sztringet melynek ertekul adjuk a parser.value fuggveny visszateresi erteket ami a parameterul adott kapcsolo nev erteke, ehhez a kapcsolot hozzakellett adnunk a parser.addOption fuggvennyel. A qsrand fuggvennyel random szamokat  generalunk a parameterul adott mennyisegben ami a QDateTime::currentMSecsSinceEpoch() fuggveny visszatersi erteke azaz hogy hany miliszekundum telt el 1970-01-01T00:00:00.000 ota. Majd letrehozunk egy w nevu objtektumot az AntWin osztalyhoz parametizalt konstruktor segitsegevel, a parameterkben hasznalt toInt fuggveny egesz tipura konvertalja a . elott levo sztringet. A show fuggvennyel tesszuk lathatova az objektumot es az exec fuggvennyel beallitjuk hogy csak akkor zarodjon be az ablak ha a felhasznalo zarja be. Az antwin.h fajlban definialjuk az AntWin alosztalyt a QMainWindow foosztalybol melyben a     Q_OBJECT markot hasznaljuk a privat reszben mivel sajat szignallal hasznaljuk az oszalyt. A publikus reszben definialjuk a parametizalt konstruktort a megfelelo kezdoertekekkel es a QWidget *parent = 0 parametrrel pedig beallitjuk hogy a QWidget foosztalya legyen az objektumnak kiveve ha nem adunk meg erteket. Az AntThread osztalynak dekralalunk egy mutato valtozojat antThread neven. Letrehozunk egy closeEvent fuggvenyt melyben mutatokkal hivatkozunk fuggvenyekre. Definialjuk a keyPressEvent fuggvenyt melyben definialjuk hogy ha a P billentyut lenyomasakor meghivodik az antThread valtozo altal mutatott pause fuggvenyt, ha pedig a Q vagy az Escape billentyu kerul lenyomasra akkor a close fuggveny hivodik meg. Mivel alosztalyt hasznalunk igy a destruktort a virtual szoval definialjuk. Definialjuk a PaintEvent fuggvenyt, majd a privat reszben egy Ants osztaly mutato tipusu valtozot ants neven es egesz tipusu valtozokat egy es ket es harom dimenzios tombot. Definialjuk a slot-kent a step fuggvenyt ami azt jelenti hogy a szignalok tudnak ra csatlakozni. Az antthread.h fajlban a QThread alosztalyt definialjuk melynek foosztalya a QThread osztaly. A Q_OBJECT markot definailjuk a szignalok es szlotok hasznalata miatt, definialjuk a konstruktorat az AntThread osztalynak melynek parametereit egesz tipusu valtozok es az Ants osztalynak egy mutato valtozoja. Majd definialjuk az osztaly destruktorat, a run fuggvenyt, a finish fuggvenyt ami false-ra allitja a running valtozo erteket, a pause fuggvenyt ami ellenkezojere allitja a paused valtozo erteket es az isRunnung fuggvenyt ami visszaadja a running valtozo erteket. A privat reszben definialjuk bool tipussal a running es a paused valtozot true es false kezdoertekekkel, egesz tipusu valtozokat, az Ants tipusu mutato valtozot, egy harom es egy ket dimenzios tombot, a timeDevel fuggvenyt, a newDir fuggvenyt, a detDirs fuggvenyt, a moveAnts fuggvenyt, a s sumNbhs fuggvenyt es a setPheromone fuggvenyt es a step fuggvenyt szignalkent. Az ant.h fajlban letrehozzuk az Ant osztalyt amiben x, y, dir valtozokat egesz tipussal dekralaljuk es az Ant konstruktor x es y parametereinek segitsegevel definialjuk oket es a konstruktorban a dir valtozo erteket a grand fuggveny altal generalt szam es a nyolccal valo maradekos osztas hatarozza meg, igy egy 0 es 8 kozotti szamot kapunk mivel 8 irany van a negyzetes halon. Letrehozunk egy Ants nevu vektort Ant tipusu elemekkel es typedef tipussal igy a kesobbi hasznalatkor nem szukseges a tipusat eleerni csak a nevet a vektornak. Definialjuk az AntWin osztaly konstruktorat melynek a QWideget a foosztaly aminek a QMainWindow a foosztalya. A konstruktorban beaalitjuk az ablak cimet Ant SImulation-re a SetWindowTitle fuggvennyel. A this->x=x paranncsal beallitjuk az aktualis objektum x valtozojanak erteket a konstruktori x valtozo ertekere, a cellWidths es a cellHights valotozok ertekeit 6-ra allitjuk ezek adjak meg majd a cellak pixel meretet. A setFixedSize ( QSize ( width*cellWidth, height*cellHeight ) ); paranccsal beallitjuk az ablak meretet fixre amit a cellak szama es a cellak merete ad meg. Letrehozunk grids neven 2 matrixot withs*hights meretben amivel foglalunk heap memoriat a cellaknak. Letrehozzuk a gridIdx valtozot inicializaljuk 0 ertekkel majd a grid valtozot inicializaljuk a 0-ik indexu valtozoban majd for ciklust hasznalva a matrix ertekeit a cellDef valtozo ertekevel tesszuk egyenlove. Letrehozunk egy vektort ants neven az Ant osztaly segitsegevel, majd egy AntThread objektumot antThread neven. A connect fugvvennyel kapcsoljuk ossze az antThread objektum szignaljat az aktualis objektum slotjava. Az antThread objektumra meghivjuk a start slot fuggvenyt ami majd meghivja a run fuggvenyt. Definialunk egy paintEvent-et melyben letrehozunk egy QPainter osztalyhoz esgy qpainter nevu objektumot aktualis objektumkent. A grid valtozo erteket a grids vektor gridIdx indexu elemere allijtuk. Majd az egymasbaagyazott for ciklusokkal vegigmegyunk minden cellan es melyekben inicializaljuk a rel valtozot double tipussal 255.0/max ertekkel. A qpainter objektum fillRect fggvenyenek segitsegevel a QColor RGB szinkodu szine alapjan kiszinezi az elso ket parameterbol alkotott (x,y) koordinatol kiindulo harmadik*negyedik koordinata meretu  pixeltombot. Egyseges szinu lesz mivel az osszes grid matrix erteke celDef es a rel valtozo erteket is max valtozobol szamlojuk ki aminek az erteke nem valtozik. A grid matrix ertekeit ellenorizzuk egy if feltetellel hogy nem egyenloek e a min valtozo ertekevel, ha a feltetel teljesul a setPen fuggveny segitsegevel beallitjuk a toll szinet es vastagsagat 1 pixelnyire, majd a drawRect fuggveny segitsegevel rajzolunk az elso ket parameterbol alkotott (x,y) koordinatara egy harmadik*negyedik parameter meretu teglalapot. Majd minden cellanak a korvonalat hasonlokepp atszinezzuk feketere. Letrehozunk egy for ciklust amely a h objektum erteketol az ants vektorig megy, az auto azt jelenti hogy ciklus vegeieg van a valtozo a stack memoriaba. A for ciklusban qt fekete szinre es 1 pixel vastagsagura allitjuk a tollat es rajzolunk a h objektum x es y ertekei alapjan egy ket pixellel kisebb oldalu negyzetet hogy kozepen legyen a kirajzolasai (x,y) koordinatakat noveltuk 1 pixellel, majd az end fuggveny jelzi a kirajzolas veget, a kezdetet a konstruktor hivasa azaz a qpainter objektum letrehozasa jelentette. Majd definialjuk az AntWin fuggveny destruktorat melyben a delete paranccsal toroljuk a heap memorian foglalt helyeket. A step fuggvenyt definialjuk melyben a parameterul kapott gridIdx valtozo erteket ertekul adjuk az aktualis objektum gridIdx valtozojanak. Az antthread.cpp fajlban definialjuk az AntThread konstruktort melyben a lokalis valtozok inicializaljuk a hozzatartozo konstruktorbeli ertekekkel, majd letrehozunk egy ket dimenzios tombot melyeknek elemei 0-k. A qsrand fuggvennyel generalunk 1970 ota eltel miliszekundumnyi szamra allitja a pszeudosorazatot ahonnan visszateresi ertekul ad egy szamot ez a szam tobb szalon is ugyanaz lesz. Letrehozunk egy Ant osztalybeli obejtumot h neven 0, 0 kezdoertekekkel amik az x es y valtozok ertekei, majd ezek ertekeit allitjuk a heigth es width valtozok fele +20 es -20 kozti random ertekre a qrand fuggveny altal generalt random szamok segitsegevel a for ciklus minden ciklusaban ami annyiszor fut le amennyi az numAnts valtozo erteke. Majd a numAntsinCells matrix megfelelo erteket noveljuk eggyel es mentjuk a h objektumot az Ants nevu vektorba, majd a gridIdx valtozo erteket 0-ra allitjuk. Letrehozzuk a sumNbhs double tipusu fuggvenyt melynek parameterei egy harom dimenzios tomb memoriacime es harom int tipusu valtozo. A fuggvenyben inicializaljuk a sum valtozot 0.0 kezdoertekkel, majd az ifrom, ito, jfrom, fto valtozokat dekralaljuk, majd meghivjuk a detDirs fuggvenyt a megfelelo parameterekre majd a kapott i j ertekekre minden i minden j ertekere kiveve ha i is es j is 0 meghatarozzuk az s es o valtozok erteket s=row+i es c=col+j alapjan ahol az i es j valtozok a for ciklusban, mivel ezek erteke adja a grids matrix sor es oszlop koordinatajat igy a megfelelo tartomanyban fell lenniuk azaz 0 es wights-1 es hights-1 kozott. Ha a megfelelo tartomanytol kisebb az os vagy s erteke akkor a maximumra allitjuk, ha nagyobb akkor a minimumra. Az ertekuk ugye azert nem lehet mindekettonek 0 mert akkor visszakapnank a col es a row ertekeit. Majd minden ciklusban hozzaadjuk a sum valtozo erteket az elozo ertekehez ami a grids matrix s soranak o oszlopahoz tartozo erteke +1 a harmadikon, majd a fuggveny visszateresi erteke ez a sum valtozo erteke lesz. A newdir fuggveny a megfelelo feltetelnek megfelelo 0 es 7 kozotti szamot adja visszateresi ertekul. A detDirs fuggvenyben hasznaljuk a switch beepitett fuggvenyt amely a parameterul kapott ertekre hasznalja az azonos case ertekhez tartozo kodot, ami jelen esetben beallitja az ifrom, ito, jfrom, jto valtozok ertekeit es a break paranccsal kilep a fuggvenybol. A moveAnts fuggvenyben az x es y valtozokat inicializaljuk a sor es oszlop valtozok ertekeivel amik a fuggveny parametereiben vannak, majd dekralaljuk az ito, ifrom, jto, jfrom valtozokat melyeknek ertekeit a detDirs fuggveny hataroz meg a dir valtozo alapjan ami fuggveny parameter. Inicializaljuk az osszes valtozot a sumNbhs fuggveny visszateresi ertekevel, a random valtozot egy 0 es 1 kozotti random generalt szammal, majd a gvalseg valtozot 0 ertekkel. Majd a numNbs fuggvenyhez hasonloan meghatarozzuk a kedvezo valtozo erteket, a valseg valtozoba meghatarozzuk a kedvezo/osszes erteket, majd minden ciklusban noveljuk a gvalseg valtozo erteket a valseg valtozo ertekevel. Ha a gvalseg nagyobb egyenlo a random valtozo ertekenel akkor a vsor=s es voszlop=o valtozok ertekadasa utan a newDir fuggvenyt meghivjuk aminek erteke a moveAnts fuggveny visszateresi erteke lesz vagy ha nem teljesul az if feltetel egyik ciklusban sem akkor a dir lesz a moveAnts fuggveny visszateresi erteke es a vsor es vooszlop valtozo ertekeit y es x valtozo ertekeire amik a sor es oszlop valtozo ertkei. A timeDevel fuggvenyben a racsElotte es racsUtanna ket dimenzios tombok memoriacimenek ertekul adjuk a grids[0] es grids[1] tombok memoriacimet igy valtoznak a grids tombok ertekei. A grids tomb indexenek meghatarozasakor a (gridIdx+1)%2 kifejezest azert hasznaljuk hogy a grids tombok erteket egy gridIdx valtozo ertekbol meghatarozzuk es sima +1 az lehetne ketto is. A for ciklusokkal vegig megyunk minden i es j valtozohoz tartozo tomb ertekeken es a racsUtanna tomb erteket egyenlove tesszuk a racsElotte tomb megfelelo ertekevel, majd ellenorizzuk hogy levonjuk a racsUtanna ertkebol az evaporation valtozo erteket ha az eredmeny nagyobb egyenlo e mint 0 akkor az lesz a racsUtanna tomb erteke ha nem akkor 0. Majd for ciklussal az ants vektor elemein azaz Ant osztaly objektumaiban inicializaljuk a sor es oszlop valtozokat -1 ertekekkel es az ujirany valtozot a moveAnts fuggveny visszateresi ertekevel, majd meghivjuk a setPheromone fuggvenyta megfelelo parameterekkel, majd ellenorizzuk hogy a numAntsinCells ket dimenzios tomb erteke kisebb e mint a cellAntMax valtozo erteke akkor csokkentjuk egyel a numAntsinCells h.y es h.x-hez tartozo erteket majd noveljuk egyel numAntsinCells valtozo ertket  es a h.x es.y erteket -1-re allitjuk, a h.dir valtozojet pedig az ujertek valtozo ertekere, a gridIdex valtozo erteket pedig az ellenkezojere allitjuk. A setPheromone fuggvenyben a i es j valtozok -1 es 2 kozti ertekeivel meghatarozzuk az s es o valtozok ertekeit ha az o es s valtozokhoz tartozo racs tomb erteke kisebb egyenlo a max valtozonal noveljuk a pheromone valtozo ertekevel ha nem akkor az erteke a max valtozo erteke lesz, majd a racs tomb sor es oszlop valtozohoz tatozo ertekevet hasonloan hatarozzuk meg. A run fuggvenyben a running valtozo erteket true-ra allitjuk es a while ciklus parametere lesz igy vegtelen ciklus lesz amiben az msleep fuggvennyel kesleltetjuk a ciklus vegrehajtasat a delay valtozo erteke altal meghatarozott miliszekundummal, majd ha a paused valtozo erteke hamis akkor meghivjuk a timeDevel fuggvenyt, majd a step szignalt gridIdex parameterrel. Majd definialjuk az AntThread osztaly destruktorat hogy torolje a numAntsinCells matrix altal foglalt memoriat.
	</para>
        <para>
            Megoldás videó: <link xlink:href="https://bhaxor.blog.hu/2018/10/10/myrmecologist">https://bhaxor.blog.hu/2018/10/10/myrmecologist</link>
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Java életjáték</title>
        <para>
            Írd meg Java-ban a John Horton Conway-féle életjátékot, 
            valósítsa meg a sikló-kilövőt!
        </para>
	<programlisting language="Java">
                <![CDATA[
public class Sejtautomata extends java.awt.Frame implements Runnable {

    public static final boolean ELO = true;

    public static final boolean HALOTT = false;

    protected boolean [][][] racsok = new boolean [2][][];

    protected boolean [][] racs;

    protected int racsIndex = 0;

    protected int cellaSzelesseg = 20;
    protected int cellaMagassag = 20;

    protected int szelesseg = 20;
    protected int magasság = 10;

    protected int varakozas = 1000;

    private java.awt.Robot robot;


    public Sejtautomata(int szelesseg, int magassag)
    {
        this.szelesseg = szelesseg;
        this.magassag = magassag;

        racsok[0] = new boolean[magassag][szelesseg];
        racsok[1] = new boolean[magassag][szelesseg];
        racsIndex = 0;
        racs = racsok[racsIndex];

        for(int i=0; i<racs.length; ++i)
            for(int j=0; j<racs[0].length; ++j)
                racs[i][j] = HALOTT;

        sikloKilovo(racs, 5, 60);

        addWindowListener(new java.awt.event.WindowAdapter()
        {
            public void windowClosing(java.awt.event.WindowEvent e)
            {
                setVisible(false);
                System.exit(0);
            }
        });

        addKeyListener(new java.awt.event.KeyAdapter()
        {

            public void keyPressed(java.awt.event.KeyEvent e)
            {
                if(e.getKeyCode() == java.awt.event.KeyEvent.VK_K)
                {

                    cellaSzelesseg /= 2;
                    cellaMagassag /= 2;
                    setSize(Sejtautomata.this.szelesseg*cellaSzelesseg,
                            Sejtautomata.this.magassag*cellaMagassag);
                    validate();
                } 
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_N)
                {

                    cellaSzelesseg *= 2;
                    cellaMagassag *= 2;
                    setSize(Sejtautomata.this.szelesseg*cellaSzelesseg,
                            Sejtautomata.this.magassag*cellaMagassag);
                    validate();
                }

                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_G)
                    varakozas /= 2;
                else if(e.getKeyCode() == java.awt.event.KeyEvent.VK_L)
                    varakozas *= 2;
                repaint();
            }
        });

        addMouseListener(new java.awt.event.MouseAdapter()
        {

            public void mousePressed(java.awt.event.MouseEvent m)
            {

                int x = m.getX()/cellaSzelesseg;
                int y = m.getY()/cellaMagassag;
                racsok[racsIndex][y][x] = !racsok[racsIndex][y][x];
                repaint();
            }
        });

        addMouseMotionListener(new java.awt.event.MouseMotionAdapter()
        {

            public void mouseDragged(java.awt.event.MouseEvent m)
            {
                int x = m.getX()/cellaSzelesseg;
                int y = m.getY()/cellaMagassag;
                racsok[racsIndex][y][x] = ELO;
                repaint();
            }
        });

        cellaSzelesseg = 10;
        cellaMagassag = 10;

        try
        {
            robot = new java.awt.Robot(
                    java.awt.GraphicsEnvironment.
                    getLocalGraphicsEnvironment().
                    getDefaultScreenDevice());
        }
        catch(java.awt.AWTException e)
        {
            e.printStackTrace();
        }

        setTitle("Sejtautomata");
        setResizable(false);
        setSize(szelesseg*cellaSzelesseg,
                magassag*cellaMagassag);
        setVisible(true);

        new Thread(this).start();
    }

    public void paint(java.awt.Graphics g)
    {

        boolean [][] racs = racsok[racsIndex];

        for(int i=0; i<racs.length; ++i)
        {
            for(int j=0; j<racs[0].length; ++j)
            { 

                if(racs[i][j] == ELO)
                    g.setColor(java.awt.Color.BLACK);
                else
                    g.setColor(java.awt.Color.WHITE);
                g.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                        cellaSzelesseg, cellaMagassag);

                g.setColor(java.awt.Color.LIGHT_GRAY);
                g.drawRect(j*cellaSzelesseg, i*cellaMagassag,
                        cellaSzelesseg, cellaMagassag);
            }
        }
    }

    public int szomszedokSzama(boolean [][] racs,
            int sor, int oszlop, boolean allapot)
    {        
        int allapotuSzomszed = 0;

        for(int i=-1; i<2; ++i)
            for(int j=-1; j<2; ++j)

                if(!((i==0) && (j==0)))
                {

                int o = oszlop + j;
                 if(o < 0)
                    o = szelesseg-1;
                 else if(o >= szelesseg)
                    o = 0;
            
                int s = sor + i;
                if(s < 0)
                    s = magassag-1;
                 else if(s >= magassag)
                    s = 0;
            
            if(racs[s][o] == allapot)
                ++allapotuSzomszed;
                }
        
        return allapotuSzomszed;
    }

    public void idoFejlodes()
    {
        
        boolean [][] racsElotte = racsok[racsIndex];
        boolean [][] racsUtana = racsok[(racsIndex+1)%2];
        
        for(int i=0; i<racsElotte.length; ++i)
        { 
            for(int j=0; j<racsElotte[0].length; ++j)
            {
                
                int elok = szomszedokSzama(racsElotte, i, j, ELO);
                
                if(racsElotte[i][j] == ELO)
                {

                    if(elok==2 || elok==3)
                        racsUtana[i][j] = ELO;
                    else
                        racsUtana[i][j] = HALOTT;
                } 
                else
                {

                    if(elok==3)
                        racsUtana[i][j] = ELO;
                    else
                        racsUtana[i][j] = HALOTT;
                }
            }
        }
        racsIndex = (racsIndex+1)%2;
    }

    public void run()
    {
        
        while(true)
        {
            try
            {
                Thread.sleep(varakozas);
            }

            catch (InterruptedException e) {}
            
            idoFejlodes();
            repaint();
        }
    }

    public void siklo(boolean [][] racs, int x, int y)
    {
        
        racs[y+ 0][x+ 2] = ELO;
        racs[y+ 1][x+ 1] = ELO;
        racs[y+ 2][x+ 1] = ELO;
        racs[y+ 2][x+ 2] = ELO;
        racs[y+ 2][x+ 3] = ELO;
        
    }
  
    public void sikloKilovo(boolean [][] racs, int x, int y)
    {
        
        racs[y+ 6][x+ 0] = ELO;
        racs[y+ 6][x+ 1] = ELO;
        racs[y+ 7][x+ 0] = ELO;
        racs[y+ 7][x+ 1] = ELO;
        
        racs[y+ 3][x+ 13] = ELO;
        
        racs[y+ 4][x+ 12] = ELO;
        rács[y+ 4][x+ 14] = ELO;
        
        racs[y+ 5][x+ 11] = ELO;
        racs[y+ 5][x+ 15] = ELO;
        racs[y+ 5][x+ 16] = ELO;
        racs[y+ 5][x+ 25] = ELO;
        
        racs[y+ 6][x+ 11] = ELO;
        racs[y+ 6][x+ 15] = ELO;
        racs[y+ 6][x+ 16] = ELO;
        racs[y+ 6][x+ 22] = ELO;
        racs[y+ 6][x+ 23] = ELO;
        racs[y+ 6][x+ 24] = ELO;
        racs[y+ 6][x+ 25] = ELO;
       
        racs[y+ 7][x+ 11] = ELO;
        racs[y+ 7][x+ 15] = ELO;
        racs[y+ 7][x+ 16] = ELO;
        racs[y+ 7][x+ 21] = ELO;
        racs[y+ 7][x+ 22] = ELO;
        racs[y+ 7][x+ 23] = ELO;
        racs[y+ 7][x+ 24] = ELO;
        
        racs[y+ 8][x+ 12] = ELO;
        racs[y+ 8][x+ 14] = ELO;
        racs[y+ 8][x+ 21] = ELO;
        racs[y+ 8][x+ 24] = ELO;
        racs[y+ 8][x+ 34] = ELO;
        racs[y+ 8][x+ 35] = ELO;
        
        racs[y+ 9][x+ 13] = ELO;
        racs[y+ 9][x+ 21] = ELO;
        racs[y+ 9][x+ 22] = ELO;
        racs[y+ 9][x+ 23] = ELO;
        racs[y+ 9][x+ 24] = ELO;
        racs[y+ 9][x+ 34] = ELO;
        racs[y+ 9][x+ 35] = ELO;
        
        racs[y+ 10][x+ 22] = ELO;
        racs[y+ 10][x+ 23] = ELO;
        racs[y+ 10][x+ 24] = ELO;
        racs[y+ 10][x+ 25] = ELO;
        
        racs[y+ 11][x+ 25] = ELO;
        
    }
   
    public void update(java.awt.Graphics g)
    {
        paint(g);
    }    

    public static void main(String[] args)
    {

        new Sejtautomata(100, 75);
    }
}
	]]>
</programlisting>
	<para>
	Letrehozzuk a Sejtautomata osztalyt ami oroklodik az java.awt.Frame osztalybol es interfesze a Runnable osztaly igy ezen osztalyok fuggvenyeit hasznalhatjuk a program soran. Letrehozunk public static final tipusu valtozokat azaz az osztalyhoz tartozo konstansokat ami az jelenti hogy ertekuk nem valtozik azaz az ELO erteke true es a HALOTT erteke false marad. Letrehozunk racsok neven egy harom dimenzios tombot melynek ket sora lesz es tipsua boolen tehat igaz hamis erteku valtozokat tartalmaz majd. Letrehozunk egy ket dimenzios tombhoz mutato valtozot racs neven boolen tipussal es inicializaljuk a szukseges egesz tipusu valtozokat es letrehozunk egy robot nevu objektumot a java.awt.Robot osztalyhoz. Letrehozzuk a Sejtautomata osztaly parametizalt konstruktorat szelesseg es magassag egesz tipsusu valtozokkal, melyben az aktualis objektum valtozojanak ertekul adjuk a konstruktorbeli valtozo erteket, igy valtozokent hasznalhatjuk a konstruktorban. A racsok tomb nulladik elemenek ertekeul adunk egy ket dimenzios tombot amivel lefoglalunk magassag*szelesseg meretu memoriat boolen tipussal, hasonloan lefoglalunk memoriat a racsok[1] tomb memoriacimehez. A racsIndex valotozo erteket 0-ra allitjuk es a racs ketdimenzios tomb mutatonak ertekul adjuk a racsok tomb racsIndex elemu mutatojat. Ket egymasba agyazott for ciklus segitsegevel vegigmegyunk a racs matrix minden elemen es ertekul adjuk a HALOTT valtozot, a matrix sorainak szamat a matrix neve.length paranccsal hataroztuk meg az oszlopainak szamat pedig a nulladik sorat megszamolva a neve[0].length paranccsal, tehat a length fuggveny megadja egy egydimenzios tomb elemeinek szamat. Majd meghivjuk a siklokilovo fuggvenyt a racs, ot es hatvan parameterekkel, majd letrehozunk egy WindowEvent objektumot hogy az ablak bezaraskor megszunjon a lathatosaga es kilepjen a program is. Letrehozunk egy KeyEvent objektumot is melyben megadjuk hogy a K billentyu lenyomasa eseten a CellaSzelesseg es CellaMagassag valtozok erteket a felere allitjuk es az ablakmeretet is atallitjuk az aktualis objektumhoz tartozo szelesseg es magassag valtozok ertekeit megszorozva a CellaSzelesseg es CellaMagassag valtozokkal. A validate fuggvennyel ervenyesitjuk az ujrameretezest. Az N billentyu lenyomasakor hasonloan szamoljuk csak felezes helyett most ketszeresere nagyitunk azaz ketszeresere noveljuk a cellak oldalait igy negyszeresere a meretet. A G billentyu lenyomasaval a varakozas valtozo erteket a felere csokkentjuk majd repaint fuggvennyel meghivjuk a paint fuggvenyt az ujraszinezeshez. A L billentyu lenyomasakor hasonloan ketszeresere noveljuk a varakozas nevu valtozo erteket es meghivjuk a repaint fuggvenyt az ujrrarajzolashoz. Letrehozunk egy MouseEvent objektumot is melyben az x es y valtozo ertekeiben kiszamoljuk hanyadik cellaba kattintottunk sor es oszlop szerint, ha a cellakba kattintunk az erteke a cella sorszama lesz, mivel egesz tipust hasznalunk a tort ertekenek a meghatarozasahoz ami lefele kerekiti a legkozelebbi egesz szamra azaz levagja a tizedesreszt. Majd a cella megfelelo koordinatakkal a hozzatartozo matrix erteket az ellenkezojere allitjuk es meghivjuk a repaint fuggvenyt hogy frissuljon a kep. Letrehozunk egy masik MouseEvent esemenyt a kijelolesek kezelesere amiben a kattintasoshoz hasonloan meghatarozzuk a kijelolt pixelekhez tartozo cellak sor es oszlopszamat majd az ezekhez tartozo matrix ertekeket modositjuk az ELO valtozo ertekere azaz true-ra majd meghivjuk a repait fuggvenyt. A koordinataknal az x koordinata az a vizszintes elhelyezkedes, de a matrix koordinatanal a vizszintes elhelyezkedes az oszlopszama ami a masodik [] reszbe irando, az y koordinata is hasonloan a koordinataknal az oszlopszam matrixnal viszont a sorszam. A cellaSzelesseg es cellaMagassag valtozok ertekeit 10-re allitjuk. A try hibakezelo fuggvenyben a robot mutato erteket egy java.awt.Robot objektumra allitjuk amivel meghivjuk az aktualis kornyezetre az alapertelmezett kepernyo eszkozt a hozzatartozo hibakezelessel. A setTitle fuggvennyel beallitjuk az ablak cimet Sejtautomata-ra, majd beallitjuk a setResizable fuggvennyel hogy ujrameretezheto legyen, majd megadjuk az ablak meretet a setSize fuggveny parametereul ami a cellak szamabol es egy cella meretenek szorzatabol szamitunk ki. Majd  setVisible fuggvennyel beallitjuk a megjelenitodest majd letrehozunk egy uj szalat az aktualis objektumbol es meghivjuk ra a satart fuggvenyt. Definialjuk a paint fuggvenyt melynek parametereben letrehozunk egy g objektumot a java.awt.Graphics osztalyhoz amiben letrehozunk egy racs nevu ket dimenzios tombhoz mutatot aminek ertekul adjuk a racsok matrix racsIndex elemenek memoriacimet igy a megfelelo racsok matrix ertekeivel dolgozunk. Majd a matrix minden elemen vegigmegyunk ket egymasbaagyazott for ciklussal minden cellan es egy if feltellel ellenorizzuk hogy az erteke megegyezik e az ELO valtozo ertekevel azaz igaz vagy nem, ha igaz akkor a szint feketere allitjuk, ha hamis akkor feherre majd kiszinezzuk az aktualis cella pixeleit az aktualis szinure. Majd a szint szurkere allitjuk es keretet rajzolunk az aktualis cella szelso pixeleire. Majd definialjuk a szomszedokSzama fuggvenyt egesz tipusu visszateresi ertekkel es a megfelelo parameterekkel, melyben inicializaljuk az allapotuSzomszed egesz tipusu valtozot nulla ertekkel. Majd ket egymasba agyazott for ciklus segitsegevel az adott cella minden szomszedos cellajanak ellenorizzuk az erteket es ha megfelelo akkor az allapotuSzomszed valtozo szamat noveljuk eggyel,melynek az erteke nulla es nyolc koze eso szam mivel nulla kezdoertekre allitottuk es nyolcszor novelhetjuk eggyel mivel minden cellanak nyolc szonszedja van. Az s es o valtozok hasznalata szukseges mivel a kepernyo veges igy ha elerjuk valamelyik oldal legszelso cellajat akkor a szemkozti oldal oldalhoz legkozelebbbi cellajara allijuk az erteket, mindket valtozo erteke nem lehet egyszerre nulla mivel azaz eredeti cella lenne. Majd a fuggveny  visszateresi erteke az allapotuSzomszed valtozo erte lesz. Majd definialjuk az idoFejlodes fuggvenyt melyben letrehozzuk a racsElotte es racsUtana ket dimenzios tomb tipsus mutatokat melyeknek ertekul adjuk a racsok harom dimenzios tomb megfelelo ket dimenzios tombjet melyet a racsIndex valtozo hataroz meg, ha az eloszor dekralalt racsIndex valtozo erteke egy es a lehetseges ertekek nulla es egy akkor a masodszor dekralalt valtozo ertekenek meghatarozasahoz kettovel valo maradekos osztast hasznalunk mivel ha kettovel osztunk a maradek nulla vagy egy es ugye elotte noveljuk a racsIndex valtozo erteket. Majd a racsElotte mutatohoz tartozo matrix minden erteken vegig megyunk egyesevel majd minden ciklusban kiszamitjuk hogy az adott cellanak hany igaz igazsagerteku szomszedos cellaja van. Majd ellenorizzuk hogy az aktualis cella igazsagerteke igaz e, ha igen akkor ellenorizzuk hogy a szomszedos cellaiban az igaz igasagerteku cellak szama ketto vagy harom e ha ketto vagy harom akkor a visgalt cella koordinataraval azonos koordinataja racsUtanna mutatoju matrixhoz tartozo cella erteket igazra allitjuk, ha nem ketto vagy harom akkor a hozzatartozo racsUtanna matrix cellajanak igazsagerteke hamis lesz. Ha a racsElotte igazsagerteke nem igaz akkor hasonloan allitjuk az  erteket de jelen esetben csak harom igaz igazsagerteku szomszed eseten lesz igaz egyebekent hamis lesz a cella igazsagerteke. Majd a racsIndex valtozo erteket az ellenkezojere allitjuk. A run fuggvenyben definialunk egy while vegtelen ciklust melyben a letrehozott szal objektumot altatjuk a varakozas valtozo ertekevel egyenlo miliszekundumig es definialtunk hozza hibakezelest, majd meghivjuk az idoFejlodes fuggvenyt es a repaint fuggvenyt. Definialjuk a siklo es a sikloKilovo fuggvenyeket mellyel letrehozzuk a siklot es a siklokilovot az adott racson az adott x es y cellakhoz. Definialjuk az update fuggvenyt egy java.awt.Graphics osztalybeli g objektum parameterrel melyre meghivjuk a paint fuggvenyt. Majd definialjuk a main fuggvenyt melyben letrehozunk egy Sejtautomat objektumot.
	</para>        
	<para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>Qt C++ életjáték</title>
        <para>
            Most Qt C++-ban!
        </para>
	<programlisting language="C++">
                <![CDATA[
//main.cpp
#include <QApplication>
#include "sejtablak.h"

int main(int argc, char *argv[])
{
    QApplication a(argc, argv);
    SejtAblak w(100, 75);
    w.show();

    return a.exec();
}
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//sejtablak.h
#ifndef SEJTABLAK_H
#define SEJTABLAK_H

#include <QMainWindow>
#include <QPainter>
#include "sejtszal.h"

class SejtSzal;

class SejtAblak : public QMainWindow
{
    Q_OBJECT

public:
    SejtAblak(int szelesseg = 100, int magassag = 75, QWidget *parent = 0);
    ~SejtAblak();

    static const bool ELO = true;

    static const bool HALOTT = false;
    void vissza(int racsIndex);

protected:

    bool ***racsok;
    bool **racs;
    int racsIndex;
    int cellaSzelesseg;
    int cellaMagassag;
    int szelesseg;
    int magassag;
    void paintEvent(QPaintEvent*);
    void siklo(bool **racs, int x, int y);
    void sikloKilovo(bool **racs, int x, int y);

private:
    SejtSzal* eletjatek;

};

#endif
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//sejtszal.h
#ifndef SEJTSZAL_H
#define SEJTSZAL_H

#include <QThread>
#include "sejtablak.h"

class SejtAblak;

class SejtSzal : public QThread
{
    Q_OBJECT

public:
    SejtSzal(bool ***racsok, int szelesseg, int magassag,
             int varakozas, SejtAblak *sejtAblak);
    ~SejtSzal();
    void run();

protected:
    bool ***racsok;
    int szelesseg, magassag;
    int racsIndex;
    int varakozas;
    void idoFejlodes();
    int szomszedokSzama(bool **racs,
                        int sor, int oszlop, bool allapot);
    SejtAblak* sejtAblak;

};

#endif
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//sejtablak.cpp
#include "sejtablak.h"

SejtAblak::SejtAblak(int szelesseg, int magassag, QWidget *parent)
    : QMainWindow(parent)
{
    setWindowTitle("A John Horton Conway-féle életjáték");

    this->magassag = magassag;
    this->szelesseg = szelesseg;

    cellaSzelesseg = 6;
    cellaMagassag = 6;

    setFixedSize(QSize(szelesseg*cellaSzelesseg, magassag*cellaMagassag));

    racsok = new bool**[2];
    racsok[0] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[0][i] = new bool [szelesseg];
    racsok[1] = new bool*[magassag];
    for(int i=0; i<magassag; ++i)
        racsok[1][i] = new bool [szelesseg];

    racsIndex = 0;
    racs = racsok[racsIndex];

    for(int i=0; i<magassag; ++i)
        for(int j=0; j<szelesseg; ++j)
            racs[i][j] = HALOTT;

    sikloKilovo(racs, 5, 60);


    eletjatek = new SejtSzal(racsok, szelesseg, magassag, 120, this);
    eletjatek->start();

}

void SejtAblak::paintEvent(QPaintEvent*) {
    QPainter qpainter(this);

    bool **racs = racsok[racsIndex];

    for(int i=0; i<magassag; ++i)
    {
        for(int j=0; j<szelesseg; ++j)
        {

            if(racs[i][j] == ELO)
                qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                                  cellaSzelesseg, cellaMagassag, Qt::black);
            else
                qpainter.fillRect(j*cellaSzelesseg, i*cellaMagassag,
                                  cellaSzelesseg, cellaMagassag, Qt::white);
            qpainter.setPen(QPen(Qt::gray, 1));

            qpainter.drawRect(j*cellaSzelesseg, i*cellaMagassag,
                              cellaSzelesseg, cellaMagassag);
        }
    }

    qpainter.end();
}


SejtAblak::~SejtAblak()
{
    delete eletjatek;

    for(int i=0; i<magassag; ++i)
    {
        delete[] racsok[0][i];
        delete[] racsok[1][i];
    }

    delete[] racsok[0];
    delete[] racsok[1];
    delete[] racsok;


}

void SejtAblak::vissza(int racsIndex)
{
    this->racsIndex = racsIndex;
    update();
}

void SejtAblak::siklo(bool **racs, int x, int y)
{

    racs[y+ 0][x+ 2] = ELO;
    racs[y+ 1][x+ 1] = ELO;
    racs[y+ 2][x+ 1] = ELO;
    racs[y+ 2][x+ 2] = ELO;
    racs[y+ 2][x+ 3] = ELO;

}

void SejtAblak::sikloKilovo(bool **racs, int x, int y)
{

    racs[y+ 6][x+ 0] = ELO;
    racs[y+ 6][x+ 1] = ELO;
    racs[y+ 7][x+ 0] = ELO;
    racs[y+ 7][x+ 1] = ELO;

    racs[y+ 3][x+ 13] = ELO;

    racs[y+ 4][x+ 12] = ELO;
    racs[y+ 4][x+ 14] = ELO;

    racs[y+ 5][x+ 11] = ELO;
    racs[y+ 5][x+ 15] = ELO;
    racs[y+ 5][x+ 16] = ELO;
    racs[y+ 5][x+ 25] = ELO;

    racs[y+ 6][x+ 11] = ELO;
    racs[y+ 6][x+ 15] = ELO;
    racs[y+ 6][x+ 16] = ELO;
    racs[y+ 6][x+ 22] = ELO;
    racs[y+ 6][x+ 23] = ELO;
    racs[y+ 6][x+ 24] = ELO;
    racs[y+ 6][x+ 25] = ELO;

    racs[y+ 7][x+ 11] = ELO;
    racs[y+ 7][x+ 15] = ELO;
    racs[y+ 7][x+ 16] = ELO;
    racs[y+ 7][x+ 21] = ELO;
    racs[y+ 7][x+ 22] = ELO;
    racs[y+ 7][x+ 23] = ELO;
    racs[y+ 7][x+ 24] = ELO;

    racs[y+ 8][x+ 12] = ELO;
    racs[y+ 8][x+ 14] = ELO;
    racs[y+ 8][x+ 21] = ELO;
    racs[y+ 8][x+ 24] = ELO;
    racs[y+ 8][x+ 34] = ELO;
    racs[y+ 8][x+ 35] = ELO;

    racs[y+ 9][x+ 13] = ELO;
    racs[y+ 9][x+ 21] = ELO;
    racs[y+ 9][x+ 22] = ELO;
    racs[y+ 9][x+ 23] = ELO;
    racs[y+ 9][x+ 24] = ELO;
    racs[y+ 9][x+ 34] = ELO;
    racs[y+ 9][x+ 35] = ELO;

    racs[y+ 10][x+ 22] = ELO;
    racs[y+ 10][x+ 23] = ELO;
    racs[y+ 10][x+ 24] = ELO;
    racs[y+ 10][x+ 25] = ELO;

    racs[y+ 11][x+ 25] = ELO;

}
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//sejtszal.cpp
#include "sejtszal.h"

SejtSzal::SejtSzal(bool ***racsok, int szelesseg, int magassag, int varakozas, SejtAblak *sejtAblak)
{
    this->racsok = racsok;
    this->szelesseg = szelesseg;
    this->magassag = magassag;
    this->varakozas = varakozas;
    this->sejtAblak = sejtAblak;

    racsIndex = 0;
}

int SejtSzal::szomszedokSzama(bool **racs,
                              int sor, int oszlop, bool allapot)
{
    int allapotuSzomszed = 0;

    for(int i=-1; i<2; ++i)
        for(int j=-1; j<2; ++j)

            if(!((i==0) && (j==0)))
            {

        int o = oszlop + j;
        if(o < 0)
            o = szelesseg-1;
        else if(o >= szelesseg)
            o = 0;

        int s = sor + i;
        if(s < 0)
            s = magassag-1;
        else if(s >= magassag)
            s = 0;

        if(racs[s][o] == allapot)
            ++allapotuSzomszed;
    }

    return allapotuSzomszed;
}

void SejtSzal::idoFejlodes()
{

    bool **racsElotte = racsok[racsIndex];
    bool **racsUtana = racsok[(racsIndex+1)%2];

    for(int i=0; i<magassag; ++i)
    {
        for(int j=0; j<szelesseg; ++j)
        {

            int elok = szomszedokSzama(racsElotte, i, j, SejtAblak::ELO);

            if(racsElotte[i][j] == SejtAblak::ELO)
            {

                if(elok==2 || elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
            else
            {

                if(elok==3)
                    racsUtana[i][j] = SejtAblak::ELO;
                else
                    racsUtana[i][j] = SejtAblak::HALOTT;
            }
        }
    }
    racsIndex = (racsIndex+1)%2;
}



void SejtSzal::run()
{
    while(true) {
        QThread::msleep(varakozas);
        idoFejlodes();
        sejtAblak->vissza(racsIndex);
    }

}

SejtSzal::~SejtSzal()
{
}
	]]>
</programlisting>
	<para>
	A main.cpp fajlban letrehozunk egy a objektumot a QApplication osztalyhoz, majd egy w nevu objetkumot a Sejtablak osztalyhoz a parametizalt konstruktora segitsegevel, majd beallitjuk hogy lathato legyen az objektum es a main fuggveny visszateresi ertekeben beallitjuk hogy akkor lepjen ki a program ha bezarjuk az ablakot azaz az exit fuggveny lefut. Az exec fuggveny szukseges az eventek kezelesehez is. A sejtablak.h fajlban letrehozzuk a Sejtszal osztalyt, majd a Sejtablak osztalyt a QMainWindow osztaly alosztalyakent es definialjuk benne a Q_OBJECT marcot mivel eventeket hasznalunk szignalokkal. Majd definialjuk az osztaly konstruktorat melynek parametere ket egesz tipusu valtozo es megadjuk foosztalyanak a QWidget osztalyt kiveve ha nem adunk meg harmadik parametert. Majd definialjuk az osztaly destruktorat. Letrehozunk ket static const tipusu valtozot azaz ket konstansot amik a memoriaba maradnak a program fuatasa alatt es ertekuk nem valtozik, ezek boolen tipusuak az ELO erteke igaz, a HALOTT valtozoje hamis. Majd definialjuk a vissza fuggvenyt racsIndex egesz tipusu valtozo parameterrel es void visszateresi ertekkel. A vedett reszben deklaralunk egesz tipusu valtozokat egy ket dimenzios es egy harom dimenzios tomb mutatojat es ket void tipusu fuggvenyt es egy PaintEvent esemenyt. Majd a privat reszben letrehozunk egy eletjatek nevu mutatot a Sejtablak osztalyhoz. A sejtszal.h fajlban letrehozzuk a Sejtablak osztalyt majd a Sejtszal osztalyt a QThread osztaly alosztalyakent, melyben definialjuk a Q_OBBJECT marcot es a Sejtszal konstruktorat a hasznalatos parameterekkel majd definialjuk az osztaly destruktorat, majd definialjuk a run fuggvenyt. A vedett reszben egy harom dimenzios tombot es egesz tipusu valtozokat es az idoFejlodes fuggvenyt es a szomszedokSzama parametizalt fuggvenyt majd egy sejtablak nevu mutatot a Sejtablak osztalyhoz. A header fajloknal hasznaltuk az ifndef marcot hogy ne definialjuk ketszer az egyes header fajlokat. A sejtablak.cpp fajlban definialjuk a Sejtablak osztaly konstruktorat melynek parameterei ket egesz tipusu  valtozo a szelesseg es magassag es a QWidget osztalyhoz egy mutato tipusu valtozot parent neven, majd a QMainWindow foosztaly konstruktoranak parameterul adjuk a parent objektum erteket. Majd aa setWindowTitle segitsegevel beallitjk az ablak nevet A John Horton Conway-féle életjáték nevre majd a szelesseg es magassag kosntruktori valtozok erteket kezdoertekul adjuk az adott objektum szelesseg es magassag lokalis valtozoinak majd inicializaljuk a cellaSzelesseg es cellaMagassag valtozok ertekeit hattal. Majd a setFixedSize fuggveny segitsegevel beallitjuk a QSize fuggvenyben megadott abalkmeretet fixre. A racsok harom dimenzios tomb mutatonak ertekul adunk ket ketdimenzios tomb memoriacimet, majd a mindket ket dimenzios tombnek lefoglalunk magassag*szelesseg meretnyi memoriat a heapen. Majd a racsIndex valtozo erteket nullara allitjuk es a racs mutato erteket a racsok harom deimenzios tomb megfelelo ket dimenzios altombjere allitjuk jelen esetben a racsIndex valtozo ertekujere ami nulla. Ennek a matrixnak minden elemenek az erteket a HALOTT valtozo ertekere azaz hamisra allitjuk. Majd meghivjuk a racs tombre es ot es hatvan parameterre a sikloKilovo fuggvenyt. Majd eletjatek Sejtosztaly tipusu mutatonak ertekul adunk egy uj objektumot amit a Sejtosztaly konstruktoraval hozunk letre a racsok harom dimenzios tomb mutatojaval, szelesseg, magassag valtozokkal es szazhusz ertekkel es az aktualis objektum objektum memoriacime parameterekkel. Majd az eletjatek mutato objektumara meghivjuk a start fuggvenyt. Majd definialunk egy paintEvent-et melyben letrehozunk egy qpainter objektumot aktualis objektum parameterrel QPainter osztalybol majd letrehozunk egy ket dimenzios tombhoz memoriacimet racs neven melynek ertekul adjuk a racsok tomb racsIndex indexu tombjenek memoriacimet. Majd a racs matrix minden elemenek erteket ellenorizzuk hogy egyenlo e az ELO valtozo ertekevel azaz igaz igazsagerteku e. Ha teljesul a feltetel akkor feketere festjuk az adott cella pixeleit ha nem teljesul akkor feherre festjuk, majd minden cellanak a szelso pixeleit szurkere festjuk. Majd meghivjuk az end fuggvenyt jelezve a festes veget. Majd definialjuk a Sejtablak destruktorat melyben toroljuk a heapen foglalt mutatokat az objektumnak foglaltat es a 3 dimenzios tombnek foglaltakat. Definialjuk a vissza fuggvenyt egesz tipusu racsIndex parameterekkel melyben az aktualis objektum racsIndex valtozojanak ertekul adjuk a fuggveny parameterkent adott erteket, majd meghivjuk az update fuggvenyt. Definialjuk a siklo es sikloKilovo fuggvenyeket amelyek adott ketdimenzios tombnek az x es y elemeire megadjak a siklo es a siklokilovot. A sejtszal.cpp fajlban a letrehozzuk a Sejtszal osztaly konstruktorat melyben inicializaljuk az aktualis objektum lokalis valtozoit a konstruktori ertekukkel majd a racsIndex valtozo erteket nullara allijtuk. Majd definialjuk a szomszedokSzama fuggvenyt melyben az allapotuSzomszed valtozoba meghatarozzuk hany adott igazsagerteku szomszedos cellaja van az adott cellanak, mivel egy cella egy matrix koordinata igy noveljuk a matrix koordinatait a megfelelo -1 es 1 kozti ertekekkel soronkent minden oszlopra, kivive 0 es 0 ertekkel mivel azzal az eredeti cellan maradnank es az ablak szelet atlepve az ellentetes oldal legszelso cellainak ertekeivel dolgozunk. Az idoFejlodes fuggvenyben letrehozunk ket ket dimenzios tomb mutatot racsElotte es racsUtanna neven melyeknek ertekei a racsok matrix megfelelo indexu elemeinek mutatoja. A megfelelo index meghatarozasahoz a racsIndex valtozo erteket noveljuk eggyel majd maradekos osztast vegzunk rajta kettovel igy ha az eloszor megadott racsIndex ertek egy akkor a masodik nulla lesz. Majd ket egymasa agyazott for ciklus segitsegevel a racsElotte mutatohoz tartozo matrix minden elemere meghatarozzuk az elok egesz tipusu valtozo erteket a szomszedokSzama fuggveny segitsegevel. Majd egy if feltetel segitsegevel ellenorizzuk hogy a cella erteke igaz e azaz egyenlo e az ELO valtozo ertekevel, ami ugye a Sejtablak osztalyhoz tartozik mivel static kulcsszoval lett definialva igy hasznalatahoz az osztalynevvel kell ra hivatkozni :: operatorral, ahogy a HALOTT valtozo eseten is. Tehat ha megfelel az if feltetelnek akkor ha a hozzatartozo elok valtozo erteke 2 vagy 3 akkor a hozzatartozo racsUtanna cella erteket az ELO valtozo igazsagertekere allitjuk, ha nem teljeseul ez a feltetel akkor HALOTT-ra. Ha ugye az eredeti feltel nem teljesul tehat az aktualis cella erteke nem egyenlo az ELO valtozo ertekevel akkor ellenorizzuk hogy az elok valtozo erteke harom e ha teljesul a feltetel akkor az aktualis cellahoz tartozo racsUtanna matrixbeli cella erteket ELO valtozo ertekere allitjuk, ha nem teljeseul a feltetel akkor a cella erteket a HALOTT valtozo ertekere allitjuk. Majd a racsIndex valtozo erteket az ellenkezojere allitjuk. Definialjuk a run fuggvenyt egy while vegtelen ciklussal melyben a QThread osztalybeli fuggvenyt hasznalva altatjuk a szalat azaz kesleltetjuk az idoFejlodes fuggveny meghivasat a varakozas valtozo erteknyi miliszekundumig az msleep fuggveny segitsegevel. A varakozas valtozo erteke hatarozza meg a siklokiloves sebesseget es a siklok mozgasi sebesseget is. Majd meghivjuk az idoFejlodes fuggvenyt majd a sejtAblak mutato altal mutatott vissza fuggvenyt meghivjuk a racsIndex parameterrel. Majd meghivjuk az osztaly destruktorat.
	</para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
    <section>
        <title>BrainB Benchmark</title>
	<programlisting language="C++">
                <![CDATA[
//main.cpp
#include <QApplication>
#include <QTextStream>
#include <QtWidgets>
#include "BrainBWin.h"

int main ( int argc, char **argv )
{
        QApplication app ( argc, argv );

        QTextStream qout ( stdout );
        qout.setCodec ( "UTF-8" );

        qout << "\n" << BrainBWin::appName << QString::fromUtf8 ( " Copyright (C) 2017, 2018 Norbert Bátfai" ) << endl;

        qout << "This program is free software: you can redistribute it and/or modify it under" << endl;
        qout << "the terms of the GNU General Public License as published by the Free Software" << endl;
        qout << "Foundation, either version 3 of the License, or (at your option) any later" << endl;
        qout << "version.\n" << endl;

        qout << "This program is distributed in the hope that it will be useful, but WITHOUT" << endl;
        qout << "ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS" << endl;
        qout << "FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.\n" << endl;

        qout << QString::fromUtf8 ( "Ez a program szabad szoftver; terjeszthető illetve módosítható a Free Software" ) << endl;
        qout << QString::fromUtf8 ( "Foundation által kiadott GNU General Public License dokumentumában leírtak;" ) << endl;
        qout << QString::fromUtf8 ( "akár a licenc 3-as, akár (tetszőleges) későbbi változata szerint.\n" ) << endl;

        qout << QString::fromUtf8 ( "Ez a program abban a reményben kerül közreadásra, hogy hasznos lesz, de minden" ) << endl;
        qout << QString::fromUtf8 ( "egyéb GARANCIA NÉLKÜL, az ELADHATÓSÁGRA vagy VALAMELY CÉLRA VALÓ" ) << endl;
        qout << QString::fromUtf8 ( "ALKALMAZHATÓSÁGRA való származtatott garanciát is beleértve. További" ) << endl;
        qout << QString::fromUtf8 ( "részleteket a GNU General Public License tartalmaz.\n" ) << endl;

        qout << "http://gnu.hu/gplv3.html" << endl;

        QRect rect = QApplication::desktop()->availableGeometry();
        BrainBWin brainBWin ( rect.width(), rect.height() );
        brainBWin.setWindowState ( brainBWin.windowState() ^ Qt::WindowFullScreen );
        brainBWin.show();
        return app.exec();
}
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//BrainBWin.h
#ifndef BrainBWin_H
#define BrainBWin_H

#include <QKeyEvent>
#include <QMainWindow>
#include <QPixmap>
#include <QPainter>
#include <QFont>
#include <QFile>
#include <QString>
#include <QCloseEvent>
#include <QDate>
#include <QDir>
#include <QDateTime>
#include "BrainBThread.h"

enum playerstate {
    lost,
    found
};

class BrainBWin : public QMainWindow
{
    Q_OBJECT

    BrainBThread *brainBThread;
    QPixmap pixmap;
    Heroes *heroes;

    int mouse_x;
    int mouse_y;
    int yshift {50};
    int nofLost {0};
    int nofFound {0};

    int xs, ys;

    bool firstLost {false};
    bool start {false};
    playerstate state = lost;
    std::vector<int> lost2found;
    std::vector<int> found2lost;

    QString statDir;

public:
    static const QString appName;
    static const QString appVersion;
    BrainBWin ( int w = 256, int h = 256, QWidget *parent = 0 );

    void closeEvent ( QCloseEvent *e ) {

        if ( save ( brainBThread->getT() ) ) {
            brainBThread->finish();
            e->accept();
        } else {
            e->ignore();
        }

    }

    virtual ~BrainBWin();
    void paintEvent ( QPaintEvent * );
    void keyPressEvent ( QKeyEvent *event );
    void mouseMoveEvent ( QMouseEvent *event );
    void mousePressEvent ( QMouseEvent *event );
    void mouseReleaseEvent ( QMouseEvent *event );

    double mean ( std::vector<int> vect ) {

        if ( vect.size() > 0 ) {
            double sum = std::accumulate ( vect.begin (), vect.end (), 0.0 );
            return  sum / vect.size();
        } else {
            return 0.0;
        }
    }

    double var ( std::vector<int> vect, double mean ) {

        if ( vect.size() > 1 ) {

            double accum = 0.0;

            std::for_each ( vect.begin (), vect.end (), [&] ( const double d ) {
                accum += ( d - mean ) * ( d - mean );
            } );

            return sqrt ( accum / ( vect.size()-1 ) );
        } else {
            return 0.0;
        }

    }

    void millis2minsec ( int millis, int &min, int &sec ) {

        sec = ( millis * 100 ) / 1000;
        min = sec / 60;
        sec = sec - min * 60;

    }

    bool save ( int t ) {

        bool ret = false;

        if ( !QDir ( statDir ).exists() )
            if ( !QDir().mkdir ( statDir ) ) {
                return false;
            }

        QString name = statDir + "/Test-" + QString::number ( t );
        QFile file ( name + "-screenimage.png" );
        if ( file.open ( QIODevice::WriteOnly ) ) {
            ret = pixmap.save ( &file, "PNG" );
        }

        QFile tfile ( name + "-stats.txt" );
        ret = tfile.open ( QIODevice::WriteOnly | QIODevice::Text );
        if ( ret ) {
            QTextStream textStremam ( &tfile );

            textStremam << appName + " " + appVersion << "\n";
            textStremam << "time      : " <<  brainBThread->getT() << "\n";
            textStremam << "bps       : " <<  brainBThread->get_bps() << "\n";
            textStremam << "noc       : " <<  brainBThread->nofHeroes() << "\n";
            textStremam << "nop       : " <<  brainBThread->get_nofPaused() << "\n";

            textStremam << "lost      : "  << "\n";
            std::vector<int> l = brainBThread->lostV();
            for ( int n : l ) {
                textStremam << n << ' ';
            }
            textStremam <<  "\n";
            int m = mean ( l );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( l, m ) << "\n";

            textStremam << "found     : " ;
            std::vector<int> f = brainBThread->foundV();
            for ( int n : f ) {
                textStremam << n << ' ';
            }
            textStremam <<  "\n";
            m = mean ( f );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( f, m ) << "\n";

            textStremam << "lost2found: "  ;
            for ( int n : lost2found ) {
                textStremam << n << ' ';
            }
            textStremam <<  "\n";
            int m1 = m = mean ( lost2found );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( lost2found, m ) << "\n";

            textStremam << "found2lost: "  ;
            for ( int n : found2lost ) {
                textStremam << n << ' ';
            }
            textStremam <<  "\n";
            int m2 = m = mean ( found2lost );
            textStremam << "mean      : " <<  m << "\n";
            textStremam << "var       : " <<  var ( found2lost, m ) << "\n";

            if ( m1 < m2 ) {
                textStremam << "mean(lost2found) < mean(found2lost)" << "\n";
            }

            int min, sec;
            millis2minsec ( t, min, sec );
            textStremam << "time      : " <<  min  << ":"  << sec << "\n";

            double res = ( ( ( ( double ) m1+ ( double ) m2 ) /2.0 ) /8.0 ) /1024.0;
            textStremam << "U R about " << res << " Kilobytes\n";

            tfile.close();
        }
        return ret;
    }

public slots :

    void updateHeroes ( const QImage &image, const int &x, const int &y );
    //void stats ( const int &t );
    void endAndStats ( const int &t );
};

#endif // BrainBWin

	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//BrainBThread.h
#ifndef BrainBThread_H
#define BrainBThread_H

#include <QThread>
#include <QSize>
#include <QImage>
#include <QDebug>
#include <sstream>
#include <QPainter>
#include <cstdlib>
#include <ctime>
#include <vector>
#include <opencv2/opencv.hpp>
#include <opencv2/core/core.hpp>
#include <opencv2/imgproc/imgproc.hpp>

class Hero;
typedef std::vector<Hero> Heroes;

class Hero
{

public:
    int x;
    int y;
    int color;
    int agility;
    int conds {0};
    std::string name;

    Hero ( int x=0, int  y=0, int color=0, int agility=1,  std::string name ="Samu Entropy" ) :
        x ( x ), y ( y ), color ( color ), agility ( agility ), name ( name )
    {}
    ~Hero() {}

    void move ( int maxx, int maxy, int env ) {

        int newx = x+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 ) ;
        if ( newx-env > 0 && newx+env < maxx ) {
            x = newx;
        }
        int newy = y+ ( ( ( double ) agility*1.0 ) * ( double ) ( std::rand() / ( RAND_MAX+1.0 ) )-agility/2 );
        if ( newy-env > 0 && newy+env < maxy ) {
            y = newy;
        }

    }

};

class BrainBThread : public QThread
{
    Q_OBJECT

    
     //Norbi
    cv::Scalar cBg { 247, 223, 208 };
    cv::Scalar cBorderAndText { 47, 8, 4 };
    cv::Scalar cCenter { 170, 18, 1 };
    cv::Scalar cBoxes { 10, 235, 252 };
    

    /*
    //Matyi
    cv::Scalar cBg { 86, 26, 228 };
    cv::Scalar cBorderAndText { 14, 177, 232 };
    cv::Scalar cCenter { 232, 14, 103 };
    cv::Scalar cBoxes { 14, 232, 195 };
*/
    
    Heroes heroes;
    int heroRectSize {40};

    cv::Mat prev {3*heroRectSize, 3*heroRectSize, CV_8UC3, cBg };
    int bps;
    long time {0};
    long endTime {10*60*10};
    int delay {100};

    bool paused {true};
    int nofPaused {0};

    std::vector<int> lostBPS;
    std::vector<int> foundBPS;

    int w;
    int h;
    int dispShift {40};

public:
    BrainBThread ( int w = 256, int h = 256 );
    ~BrainBThread();

    void run();
    void pause();
    void set_paused ( bool p );
    int getDelay() const {

        return delay;

    }
    void setDelay ( int delay ) {

        if ( delay > 0 ) {
            delay = delay;
        }

    }

    void devel() {

        for ( Hero & hero : heroes ) {

            hero.move ( w, h, ( h<w ) ?h/10:w/10 );

        }

    }

    int nofHeroes () {

        return  heroes.size();

    }

    std::vector<int> &lostV () {

        return  lostBPS;

    }

    std::vector<int> &foundV () {

        return  foundBPS;

    }

    double meanLost () {

        return  mean ( lostBPS );

    }

    double varLost ( double mean ) {

        return  var ( lostBPS, mean );

    }

    double meanFound () {

        return  mean ( foundBPS );

    }

    double varFound ( double mean ) {

        return  var ( foundBPS, mean );

    }

    double mean ( std::vector<int> vect ) {

        double sum = std::accumulate ( vect.begin (), vect.end (), 0.0 );
        return  sum / vect.size();

    }

    double var ( std::vector<int> vect, double mean ) {

        double accum = 0.0;
        std::for_each ( vect.begin (), vect.end (), [&] ( const double d ) {
            accum += ( d - mean ) * ( d - mean );
        } );

        return sqrt ( accum / ( vect.size()-1 ) );
    }

    int get_bps() const {

        return bps;

    }

    int get_w() const {

        return w;

    }


    bool get_paused() const {

        return paused;

    }

    int get_nofPaused() const {

        return nofPaused;

    }

    void decComp() {

        lostBPS.push_back ( bps );

        if ( heroes.size() > 1 ) {
            heroes.pop_back();
        }

        for ( Hero & hero : heroes ) {
            if ( hero.agility >= 5 ) {
                hero.agility -= 2;
            }

        }

    }

    void incComp() {

        foundBPS.push_back ( bps );

        if ( heroes.size() > 300 ) {

            return;

        }

        /*
        Hero other ( w/2 + 200.0*std::rand() / ( RAND_MAX+1.0 )-100,
                     h/2 + 200.0*std::rand() / ( RAND_MAX+1.0 )-100,
                     255.0*std::rand() / ( RAND_MAX+1.0 ), 11, "New Entropy" );
                     */

	double rx = 200.0;
	if(heroes[0].x - 200 < 0)
	  rx = heroes[0].x;
	else if(heroes[0].x + 200 > w)
	  rx = w - heroes[0].x;
	
	double ry = 200.0;
	if(heroes[0].y - 200 < 0)
	  ry = heroes[0].y;
	else if(heroes[0].y + 200 > h)
	  ry = h - heroes[0].y;
	
        Hero other ( heroes[0].x + rx*std::rand() / ( RAND_MAX+1.0 )-rx/2,
                     heroes[0].y + ry*std::rand() / ( RAND_MAX+1.0 )-ry/2,
                     255.0*std::rand() / ( RAND_MAX+1.0 ), 11, "New Entropy" );
		
        heroes.push_back ( other );

        for ( Hero & hero : heroes ) {

            ++hero.conds;
            if ( hero.conds == 3 ) {
                hero.conds = 0;
                hero.agility += 2;
            }

        }

    }

    void draw () {

        cv::Mat src ( h+3*heroRectSize, w+3*heroRectSize, CV_8UC3, cBg );

        for ( Hero & hero : heroes ) {

            cv::Point x ( hero.x-heroRectSize+dispShift, hero.y-heroRectSize+dispShift );
            cv::Point y ( hero.x+heroRectSize+dispShift, hero.y+heroRectSize+dispShift );

            cv::rectangle ( src, x, y, cBorderAndText );

            cv::putText ( src, hero.name, x, cv::FONT_HERSHEY_SIMPLEX, .35, cBorderAndText, 1 );

            cv::Point xc ( hero.x+dispShift , hero.y+dispShift );

            cv::circle ( src, xc, 11, cCenter, CV_FILLED, 8, 0 );

            cv::Mat box = src ( cv::Rect ( x, y ) );

            cv::Mat cbox ( 2*heroRectSize, 2*heroRectSize, CV_8UC3, cBoxes );
            box = cbox*.3 + box*.7;

        }

        cv::Mat comp;

        cv::Point focusx ( heroes[0].x- ( 3*heroRectSize ) /2+dispShift, heroes[0].y- ( 3*heroRectSize ) /2+dispShift );
        cv::Point focusy ( heroes[0].x+ ( 3*heroRectSize ) /2+dispShift, heroes[0].y+ ( 3*heroRectSize ) /2+dispShift );
        cv::Mat focus = src ( cv::Rect ( focusx, focusy ) );

        cv::compare ( prev, focus, comp, cv::CMP_NE );

        cv::Mat aRgb;
        cv::extractChannel ( comp, aRgb, 0 );

        bps = cv::countNonZero ( aRgb ) * 10;

        //qDebug()  << bps << " bits/sec";

        prev = focus;

        QImage dest ( src.data, src.cols, src.rows, src.step, QImage::Format_RGB888 );
        dest=dest.rgbSwapped();
        dest.bits();

        emit heroesChanged ( dest, heroes[0].x, heroes[0].y );

    }

    long getT() const {

        return time;

    }

    void finish () {

        time = endTime;

    }


signals:

    void heroesChanged ( const QImage &image, const int &x, const int &y );
    void endAndStats ( const int &t );

};

#endif // BrainBThread_H


	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//BrainBWin.cpp
#include "BrainBWin.h"

const QString BrainBWin::appName = "NEMESPOR BrainB Test";
const QString BrainBWin::appVersion = "6.0.3";

BrainBWin::BrainBWin ( int w, int h, QWidget *parent ) : QMainWindow ( parent )
{

//    setWindowTitle(appName + " " + appVersion);
//    setFixedSize(QSize(w, h));

        statDir = appName + " " + appVersion + " - " + QDate::currentDate().toString() + QString::number ( QDateTime::currentMSecsSinceEpoch() );

        brainBThread = new BrainBThread ( w, h - yshift );
        brainBThread->start();

        connect ( brainBThread, SIGNAL ( heroesChanged ( QImage, int, int ) ),
                  this, SLOT ( updateHeroes ( QImage, int, int ) ) );

        connect ( brainBThread, SIGNAL ( endAndStats ( int ) ),
                  this, SLOT ( endAndStats ( int ) ) );

}

void BrainBWin::endAndStats ( const int &t )
{

        qDebug()  << "\n\n\n";
        qDebug()  << "Thank you for using " + appName;
        qDebug()  << "The result can be found in the directory " + statDir;
        qDebug()  << "\n\n\n";

        save ( t );
        close();
}

void BrainBWin::updateHeroes ( const QImage &image, const int &x, const int &y )
{

        if ( start && !brainBThread->get_paused() ) {

                int dist = ( this->mouse_x - x ) * ( this->mouse_x - x ) + ( this->mouse_y - y ) * ( this->mouse_y - y );

                if ( dist > 121 ) {
                        ++nofLost;
                        nofFound = 0;
                        if ( nofLost > 12 ) {

                                if ( state == found && firstLost ) {
                                        found2lost.push_back ( brainBThread->get_bps() );
                                }

                                firstLost = true;

                                state = lost;
                                nofLost = 0;
                                //qDebug() << "LOST";
                                //double mean = brainBThread->meanLost();
                                //qDebug() << mean;

                                brainBThread->decComp();
                        }
                } else {
                        ++nofFound;
                        nofLost = 0;
                        if ( nofFound > 12 ) {

                                if ( state == lost && firstLost ) {
                                        lost2found.push_back ( brainBThread->get_bps() );
                                }

                                state = found;
                                nofFound = 0;
                                //qDebug() << "FOUND";
                                //double mean = brainBThread->meanFound();
                                //qDebug() << mean;

                                brainBThread->incComp();
                        }

                }

        }
        pixmap = QPixmap::fromImage ( image );
        update();
}

void BrainBWin::paintEvent ( QPaintEvent * )
{
        if ( pixmap.isNull() ) {
                return;
        }

        QPainter qpainter ( this );

        xs = ( qpainter.device()->width() - pixmap.width() ) /2;
        ys = ( qpainter.device()->height() - pixmap.height() +yshift ) /2;

        qpainter.drawPixmap ( xs, ys, pixmap );

        qpainter.drawText ( 10, 20, "Press and hold the mouse button on the center of Samu Entropy" );

        int time = brainBThread->getT();
        int min, sec;
        millis2minsec ( time, min, sec );
        QString timestr = QString::number ( min ) + ":" + QString::number ( sec ) + "/10:0";
        qpainter.drawText ( 10, 40, timestr );

        int bps = brainBThread->get_bps();
        QString bpsstr = QString::number ( bps ) + " bps";
        qpainter.drawText ( 110, 40, bpsstr );

        if ( brainBThread->get_paused() ) {
                QString pausedstr = "PAUSED (" + QString::number ( brainBThread->get_nofPaused() ) + ")";

                qpainter.drawText ( 210, 40, pausedstr );
        }

        qpainter.end();
}

void BrainBWin::mousePressEvent ( QMouseEvent *event )
{

        brainBThread->set_paused ( false );

}

void BrainBWin::mouseReleaseEvent ( QMouseEvent *event )
{

        //brainBThread->set_paused(true);

}

void BrainBWin::mouseMoveEvent ( QMouseEvent *event )
{

        start = true;

        mouse_x = event->pos().x() -xs - 60;
        //mouse_y = event->pos().y() - yshift - 60;
        mouse_y = event->pos().y() - ys - 60;
}

void BrainBWin::keyPressEvent ( QKeyEvent *event )
{

        if ( event->key() == Qt::Key_S ) {
                save ( brainBThread->getT() );
        } else if ( event->key() == Qt::Key_P ) {
                brainBThread->pause();
        } else if ( event->key() == Qt::Key_Q ||  event->key() == Qt::Key_Escape ) {
                close();
        }

}

BrainBWin::~BrainBWin()
{

}
	]]>
</programlisting>

	<programlisting language="C++">
                <![CDATA[
//BrainBThread.cpp
#include "BrainBThread.h"

BrainBThread::BrainBThread ( int w, int h )
{

        dispShift = heroRectSize+heroRectSize/2;

        this->w = w - 3 * heroRectSize;
        this->h = h - 3 * heroRectSize;

        std::srand ( std::time ( 0 ) );

        Hero me ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                  this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 9 );

        Hero other1 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Norbi Entropy" );
        Hero other2 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 3, "Greta Entropy" );
        Hero other4 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 5, "Nandi Entropy" );
        Hero other5 ( this->w / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100,
                      this->h / 2 + 200.0 * std::rand() / ( RAND_MAX + 1.0 ) - 100, 255.0 * std::rand() / ( RAND_MAX + 1.0 ), 7, "Matyi Entropy" );

        heroes.push_back ( me );
        heroes.push_back ( other1 );
        heroes.push_back ( other2 );
        heroes.push_back ( other4 );
        heroes.push_back ( other5 );

}

BrainBThread::~BrainBThread()
{

}

void BrainBThread::run()
{
        while ( time < endTime ) {

                QThread::msleep ( delay );

                if ( !paused ) {

                        ++time;

                        devel();

                }

                draw();

        }

        emit endAndStats ( endTime );

}

void BrainBThread::pause()
{

        paused = !paused;
        if ( paused ) {
                ++nofPaused;
        }

}

void BrainBThread::set_paused ( bool p )
{

        if ( !paused && p ) {
                ++nofPaused;
        }

        paused = p;

}
	]]>
</programlisting>
	<para>
	A main.cpp fajlban letrehozunk egy app nevu objektumot a QApplication osztalyhoz, majd letrehozunk egy objektumot a QTextStream osztalyhoz qout neven melynek konstruktoraba az stdout kerul ami a szabvanyos kimenetre utal tehat a szabvanyos kimenetet hasznalja kiiratasra. Beallitjuk a setCodec fuggveny segitsegevel a szoveg kodolasat UTF-8-ra, majd a kiirando szoveget a cout-hoz hasonloan kiiratjuk mivel ezzel is egy csatornat hoztunk letre a kimenetre, de jelen esetben qout-ot hasznalunk. Kiiratjuk a BrainBWin osztalynak az appName valtozojanak erteket, a magyar szovegreszeknel ahol van benne ekezetes betu is a hatekony kodolas erdekeben jelezzuk hogy UTF-8 kodolasu a szoveg ugy hogy a QString osztaly fromUtf8 fuggvenyebe irjuk a szoveget, a \n es az endl is az ujsort jelentik es tobbszor is hasznalhatoak egymas utan, de jelen esetben a kod formalitasa miatt egyet egyet hasznaltunk belole. Letrehozzuk a QRect osztaly rect nevu objektumat melynek erteke a QApplication osztaly desktop fuggvenyeve meghivja az availableGeometry fuggvenyt, ami meghatarozza hogy mekkora teruletu hely van az applikacio szamara az ablakban. Majd letrehozzuk a BrainBWin osztalynak egy objektumat brainBWin neven a rect.width es rec.heigth adatokkal azaz a rekt objektumban levo width fuggvenyre hivatkozunk ami megadja ugye az asztalon az applikaciok szamara rendelkezesre allo hely szelesseget, a height fuggveny pedig a magassagat. A setWindowState fuggveny segitsegevel beallitjuk a kepernyo merettipusat, jelen esetben teljes kepernyoben azaz nincs keret az ablak korul hanem kitolti a teljes ablakot. Mivel xor-osan kezeli a parameterul kapott erteket a windowState igy megadhatjuk xor muvelettel is. Majd lathatova tesszuk a show fuggveny segitsegevel a brainBWin objektumot, majd a main fuggveny visszateresi erteket az exec fuggvenyre allitjuk aminek nulla ha meghivodik az exit fuggveny azaz bezarjuk az ablakot es az eventek hasznalatahoz is szukseges. Letrehozunk az enum segitsegevel egy tipust playerstate neven melyben definialjuk a hozzatartozo valtozokat lost es found neven. Majd definialjuk a BrainBWin osztalyt a QMainWindow osztaly alosztalyakent melyben hasznaljuk a Q_OBJECT marcot mivel szignalokat hasznalunk, majd letrehozunk egy mutatatot a BrainBThread osztalyhoz brainBThread neven, majd letrehozunk egy objektumot a QPixmap osztalyhoz pixmap neven, majd letrehozunk egy mutatot a Heroes osztalyhoz heroes neven. Majd dekralaljuk es incializaljuk a szukseges valtozokat a megfelelo kezdoertekekkel es letrehozunk ket egesz tipusu vektort lost2found es found2lost neven, majd letrehozunk egy QString objektumot statDir neven. Majd letrehozunk ket static const tipsusu QString objektumot appName es appVersion neven mivel nem parametizalt konstruktort hasznalunk igy ket ures sztringet melyek az osztalyhoz tartoznak es erteiket egyszer lehet megadni objektumonkent. Majd definialjuk a BrainBWin osztaly konstruktorat melynek parametereit incicializaljuk a w es h egesz tipusu valtozokat ketszazotvenhat kezdoertekekkel es a QWidget *parent mutatot nulla kezdoertekkel. Majd letrehozunk egy closeEvent-et melyben egy if feltetellel ellenorizzuk a save fuggveny visszateresi erteke melynek parametere hogy a brainThread mutato objektumara meghivjuk a getT fuggvenyt, ha igaz a save fuggveny visszateresi erteke akkor a brainThread mutato objektumara meghivjuk a finish fuggvenyt ami leallitja a run fuggvenyt, majd az event objektumara meghivjuk az accept fuggvenyt ami engedelyezi az ablak bezarasat, ha nem teljesul a felteltel akkor az event objektumara az ignore fuggveny hivodik meg a nem engedelyezi az ablak bezarasat igy nem tudjuk bezarni az ablakot. Majd definialjuk a brainBWin virtualis destruktorat a virtual kifejezessel, melyet akkor hasznalunk ha az adott osztalyt foosztalykent hasznaljuk es nincs virtualis destruktort tartlamazo foosztalya, mivel a foosztaly virtualis destruktora meghivja az alosztalyok destruktorat. Dekralaljuk a hasznalatos esemenyeket, majd definialjuk a mean fuggvenyt double visszateresi ertekkel, melynek parametere egy egesz tipusu vektor vect nevvel. Majd a fuggvenyben ellenorizzuk egy if feltetellel hogy a parameterul adott vektor merete nagyobb e mint egy, ehhez a vektorra meghivjuk a size fuggvenyt mely megadja a vektor elemeinek a szamat. Ha teljesul az if feltetel akkor inicializaljuk a sum double tipusu valtozot az accumlate fuggveny visszateresi erteke lesz. Az accumlate osszeadja az elso parameterol a masodik parametereig az elemeket az elso es masodik parameter elemvel egyutt, a harmadik parameterben pedig megadhatjuk a kezdoerteket, ami jelen esetben 0.0. Mivel a vektor elemeit adjuk ossze igy az elso elem meghatarozasara a vektorra hasznaljuk a begin fuggvenyt, az utolso elem megatarozasara pedig az end fuggvenyt. Majd a fuggveny visszateresi erteke a sum valtozo es a vektorra meghivott size fuggveny visszateresi ertekenek a hanyadosa lesz. Ha nem teljesul az if fetetel akkor a fuggveny visszateresi erteke 0.0 lesz. Majd definialjuk a var fuggvenyt double tipussal, melynek elso parametere egy egesz tipsusu vektor neve ami jelen esetben vect, a masodik parameter double tipusu valtozo neve ami jelen esetben mean. A fuggvenyben ellenorizzuk egy if feltellel hogy a vektor merete nagyobb e mint egy, a vektor meretet a vektorra meghivott size fuggveny visszateresi erteke lesz ami a vektor elemeneinek a szama. Ha teljesul az if feltetel akkor inicializaljuk a double tipusu accum valtozot 0.0 kezdoertekkel. A vektor elemeivel valo szamolashoz a for_each fuggvenyt hasznaljuk mely az elso parameter erteketol a masodik parameter ertekeig atadja az adott erteket memoriacimet a harmadik parameterkent megadott fuggvenynek, ami egy lambda kifejezes mely a kapott parameternek veszi a referenciajat igy memoriacim helyett az erteket mentjuk a d valtozoba amivel szamolunk minden ertek eseten. Mivel a masodik parameterkent adott ertek memoriacimet nem kezeli a fuggveny igy az elemek szamabol ki kell vonni egyet mivel az utolso vektor elemmel nemszamoltunk. A parameterul adott vektor minden elemenek ertekebol kiveve az utolsoebol kivonjuk a parameterul adott mean valtozo erteket majd megszorozzuk a kapott erteket onmagaval igy negyzetre emelunk, ezek a szamitasok az accum valtozo ertekeit valtoztatjak ami double tipusu igy mivel kivonunk egesz szambol es nem a d valtozoba mentjuk vissza igy hasznalhattuk volna int azaz egesz tipussal is. Majd a fuggveny visszateresi erteke az sqrt fuggveny visszateresi erteke lesz melynek parametere a vektor elemeinek az ertekenek a mean valtozoval vett kulonbsegenek a negyzetosszegenek es a vektor elemszamanak a hanyadosa, de a az utolso vektor elemmel nem szamoltunk a for_each fuggvenyben igy a size fuggveny visszateresi ertekebol kikell vonni egyet. Ha nem teljesul az eredeti feltetel azaz a vektor elemeinek a szama nulla vagy egy akkor a fuggveny visszateresi erteke 0.0 lesz. Majd definialjuk a millis2minsec fuggvenyt void tipussal es egy egesz tipusu ertekkel es ket egesz tipusu memoriacimmel. A fuggvenyben meghatarozzuk a parameterul adott miliszekundum szazszorosanak az erteket percben es a maradek masodpercben mivel egesz szamokkal dolgozunk, ezeket az ertekeket a masodik harmadik parameterkent megadott memoriacimhez tartozo valtozo ertekiben szamoljuk. A szamitashoz hasznaltuk hogy egy masoperc ezer miliszekundum es egy perc hatvan masodperc. Az atvaltas igysem pontos mivel szaszorosaval szamolva is tizzel osztunk de egesz tipusu valtozo erteket szamolva az osztas a tizes helyierteket levagja. Majd definialjuk a save fuggvenyt bool tipussal melynek parametere egesz tipusu valtozo jelen esetben t nevvel. A fuggvenyben inicializaljuk a rev valtozot bool tipussal es hamis igazsagertekkel. Majd egy if feltetellel ellenorizzuk hogy letezik e Statdir nevu mappa az aktualis konyvtarban, ehhez a QString konstruktort hasznaljuk ami a parameterkent adott sztring nevu mappahoz ad vissza egy mutatot, az exist fuggveny pedig ellenorzi hogy letezik e a mappa ha letezik akkor a visszateresi erteke igaz, ha nem akkor hamis illetve ha azonos fajl nevu fajlt talal akkor is hamis. Majd mivel egy ! van az if feltetel elott igy ha az exist fuggveny igazsagerteke hamis akkor lepunk a beagyazott if feltetelre ahol az aktualis QT mappaba letrehozunk egy statDir nevu mappat ha mar letezik a parameterkent adott neven mappa akkor a visszateresi erteke hamis, ha nem akkor letrehoz egyet es a visszateresi erteke igaz lesz. Mivel ! jelet hasznalunk a feltetelben az mkdir fuggveny elott igy a feltel akkor teljesul ha az mkdir fuggveny visszateresi erteke hamis, ekkor az eredeti fuggveny azaz a save visszateresi erteke hamis lesz. Tehat ha letezik statDir nevu mappa akkor kilepunk a feltelbol, ha nem letezik akkor letrehozunk egyet, ha valami hiba van letrehozaskor peldaul nincs eleg tarhely akkor a masodik feltetel is igaz es kilep a fuggvenybol hamis igazsagertekkel. Lenyegeben az mkdir visszateresi erteke is meghatarozna a feltetel igazsagerteket az exec fuggveny hasznalata nelkul. Majd letrehozunk a QString osztalyhoz egy objektumot name neven tehat egy sztringet melynek erteke statDir/Test-1 ha a save fuggveny parametere egy volt. A Statdir ugye sztring tipus mivel a QDir parametere QString osztalybeli sztring, a szamot pedig a QString osztaly number fuggvenyevel hatarozzuk meg mivel valtozoba van mentve. Az osszeadas jel pedig az egybeirast jelenti, az idozejelek kozotti szoveg pedig sztring tipsu. Letrehozunk egy QFile osztalybeli objektumot file neven melynek konstruktoraban megadhatjuk a fajl nevet ami jelen esetben statDir/Test-1-screenimage.png lenne ha a save fuggveny parametere egy. A file.open fuggvennyel megnyijuk a file objektumhoz a fajlkezeleot csak iras modban, ha sikerul akkor a visszateresi ertke igaz, ha nem akkor hamis. Majd ha teljesul a feltetel akkor a ret valtozo igazsagerteke amit a pixmap objektumra meghivott save fuggveny visszateresi erteke hataroz meg. A save fuggveny parameterben mmegadjuk a fajl memoriacmet amit mentunk majd a kiterjeszteset ami PNG lesz. Sikeres mentes eseten a ret valtozo igazsagerteke igaz les, sikertelen mentes eseten hamis. Letrehozunk egy tfile nevu objektumot a QFile osztalyhoz aminek a konstruktoraval megadjuk a fajlnevet ami statDiv/Test-1-stats.txt ha a save fuggveny parametere egy. A ret valtozo erteke a tfile objektumra meghivott open fuggveny visszateresi erteke lesz ami igaz ha sikeresen letrejon az interfesz csak iras es a sorvegi kifejezesek is ertelmezodnek peldaul a \n ujsort ir. Ha a ret igazsagerteke igaz akkor teljesul a kovetkezo if feltetel melyben letrehozunk a QTextStream osztalyhoz egy objektumot textStremam neven az osztaly parametizalt konstruktoraval melyben megadjuk a memoriacimmel hogy hova irunk majd ez jelen esetben a tfile objektum memoriacime. Majd a szoveget a texStremam objektumba iranyiva a fajlba irjuk a szukseges vektorok, valtozok ertekeit es fuggvenyek visszateresi ertekeit. Majd a tfile objektumra meghivva a close fuggvenyt bezarjuk a csatornat illetve ha nem teljesul az if feltetel. Majd a save fuggveny visszateresi erteke a ret valtozo erteke azaz hibamentesseg eseten true. Majd definialjuk a slot fuggvenyeket az updateHeroes fuggvenyt melynek parameterei egy QImage konstans objektum memoriacime es ket egesz tipusu konstans valtozo memoriacime. Majd az endAndStats fuggvenyt egy egesz tipusu konstans valtozo memoriacimevel. A BrainBThread.h fajlban letrehozzuk a Hero osztalyt, majd tipusdefinialunk egy Hero osztaly tipusu elemeket azaz objektumokat tartalmazo vektort Heroes nevvel igy ilyen tipusu vektorokat Heroes vektornev paranccsal hozhatunk letre. Majd definialjuk a Hero osztalyt melyben dekralaljuk a hasznalatos egesz tipusu valtozokat es inicializalunk is egyet majd definialunk egy sztringet name neven. Majd a Hero osztaly parametizalt konstruktorat definialjuk a hozzatartozo inicializalt listaval, majd definialjuk a Hero osztaly destruktorat. Majd definialjuk a move fuggvenyt melyben a parameterul adott valtozok felteleben modositjuk az x es y valtozok ertekeit random szamok generalasa segitsegevel, melyet a rand fuggveny tesz lehetove. Majd letrehozzuk a BrainBThread osztalyt a QThread osztaly alosztalyakent, majd definialjuk a Q_OBJECT marcot a szignalok hasznalatahoz. A programban cv osztalybeli objektumokat keszitunk, a Mat osztalyhoz tartozo parametizalt konstruktorral letrehozunk egy ket dimenzios tombot, a konstruktornak az elso erteke a matrix szelesseget, a masodik parametere a matrix magassagat, a harmadik parametere a matrix tipusat jelen esetben CV_8UC3 azaz harom csatornas nyolc bites egesz tipusu elemekbol allo matrix amit az RGB szinkodokhoz hasznalunk, a negyedik parameter a matrix nevet jelenti. A long tipusu valtozok is egesz tipusuak, de nagyobb biten tarolodnak. A for ciklusban hogy vegigmenjunk a vektor elemein dekralalunk egy vektor elemet a vektor tipussal majd : vektor neve kodot hasznaljuk, ugye jelen esetben a tipusa Hero es letrehozunk egy elemet igy objektumot a Hero osztalyhoz hero neven. Az end jelet azert hasznaljuk a vektor elem elott mert az objektum memoriacime szukseges. A ? : operator hasznalatakor ha a ? elotti kifejezes igazsagerteke igaz akkor a : elotti utasitas hajtodik vegre, ha hamis akkor a : utani utasitas. Definialjuk a lostV fuggvenyt mely a lostBPS nevu vektort egy uj egesz vektor tipusu memoriacimmel latja el mivel a fuggveny visszateresi erteke referencia egy egesz tipusu vektorra ami automatikusan mereterzi magat. A fuggveny hasznalata azert szukseges mert egy masik osztalybol hivjuk az adott osztaly privat reszeben definialt vektort, melynek ertekeihez a hozzaferest a publikus reszben definialt fuggveny teszi lehetove uj memoriacimmel. Definialjuk a decComp fuggvenyt melyben a push_back fuggveny segitsegevel a parameterul adott valtozo erteket betesszuk a vektorba melyre meghivtuka fuggvenyt egy uj letrehzott utolso elemkent. A popback fuggveny segitsegevel a vektornak melyre meghivtuk kiveszzuk az utolso elemet. A decComp fuggvenyben ellenorizzuk egy if feltetel segitsegevel hogy a heroes vektor merete nagyobb e mint egy, ha nagyobb akkor kiveszunk egy elemet a vektorbol. Majd a hero vektor minden elemere ellenorizzuk egy if feltetel segitessegevel hogy a Hero osztaly hero objektumanak agility valtozoba tarolt erteke nagyobb egyenlo e mint ot, ha teljesul a feltetel csokkentjuk kettovel az agility valtozo erteket, ugye a Hero osztaly objektumai a Heroes vektor elemei. A void tipsu fuggvenyekben mivel a fuggvenyeknek nincs visszateresi erteke, igy a return szot a fuggvenybol valo kilepesre hasznalhatjuk if feltellel, ha nem a program vegen akarunk kilepni, ugy e program vegerol elhagyhato. A cv osztaly Point alosztalyanak konstruktoraval letrehozhatunk ket dimenzios pontokat objektumkent, az elso parameter a pont x koordinataja, a masodik a pont y koordinataja. A cv osztaly circle fuggvenyevel kort rajzolunk az adott parameterek alapjan, az elso parameterben megadjuk a kepet ahova rajzojuk a kort ami egy InputOutputArray osztalybeli objektum, jelen esetben Mat osztalybeli ami InputOutputArray osztalyhoz tartozik, a masodik parameterkent megadunk egy Point osztalybeli objektumot ami a kor kozeppontja lesz, a harmadik parametere egesz tipsu melyben megadhatjuk mennyi pixel legyen a kor sugara, a negyedik parameterben megadhatjuk konstans tipusu Scalar osztalybeli objektum mely megadja a kor szinet, az otodk parameterben megadhatjuk a kor vonalanak a pixel vastagsagat egesz tipusu ertekkel, mely ha negativ a kor kitoltott lesz, jelen esetben a CV_FILLED valtozo erteke -1 igy a kor kitoltott lesz, a hatodik parameterknet a kor rajzolasahoz hasznalt vonal tipust adhatjuk meg egesz tipusu ertekkel, hetedik parameterkent pedig megadhatjuk a frakciobitek szamat a kozppontban es a sugarban egesz tipusu ertekkent. A cv osztaly Scalar alosztalyanak konstruktoraval letrehozhatunk a parameterkent adott elemekbol egy objektumot az adott neven. A cv osztaly rectangle fuggvenyvel egy teglalapot rajzolhatunk, melynek elso parameterben megadhatjuk a circle fuggvenyhez hasonloan hova rajzoljon, a masodik parameterben megadhatjuk a teglalapnak egy csucsat egy Point osztalybeli objektummal, a harmadik parameterben a masodik parameterkent megadott csuccsal szmkozti csucsot adjuk meg egy Point osztalybeli objektummal, a negyedik parameterben megadhatjuk a teglalap szinet egy Scalar tipusu objektummal, a tobbi adatnak van alaperteke igy nem szukseges megadni a circle fuggvenyhez hasonloan. A cv osztaly putText fuggvenyevel megadhatjuk szoveget irhatunk alakzatokra, melynek elso parametere a circle es rectangle fuggvenyekhez hasonloan a kep ahova irunk, a masodik parameter egy String tipusu objektum ami megadja a rajzolando szoveget, a harmadik parametereben megadjuk hogy egy Point tipusu objektum segitsegevel hogy a kepen a rajzolando szoveg balalso sarka hol van, a negyedik parameterben megadjuk a betutipust ami jelen esetben normal simplex, otodik parameterkent megadjuk double tipusu szam ami a betumerethez kell, hatodik parameterkent megadjuk a szoveg szinet Scalar osztalybeli objektummal, a hetedik parameterkent megadjuk a vonal vastagsagot a rajzolashoz ami jelen esetben egy pixel, a tobbi parametert nem adtuk meg mivel az alapeterkeik megfeleloek. A cv osztaly compare fuggvenye osszehasonlitja ket tomb elemeit vagy egy tomb elemeit egy skalarral, melynek elso parametere az elso osszehasonlitando sor vagy skalar mely InputArray osztalybeli objektum melyhez tartozik a Mat osztaly melynek objektumat jelen esetben hasznaljuk, a masodik parameterkent megadjuk az elso parameterhez hasonloan a masodik osszehasonlitando sort vagy skalart, harmadik parameterkent megadhatjuk a kimeneti sort amiben ment OutputArray objektumkent melynek resze a Mat osztaly, a negyedik parameter egesz tipusu jelen esetben cv osztaly CMP_NE mely ellenorzi hogy az elso sor eleme nem egynelo e a masodik sor elemevel elemenkent, ha nem egyenlo akkor 255-ot ir a kimeneti sorba. A cv osztaly extartctChannel fuggvenyenek segitsegevel letrehozunk egy egy dimenzios sort az elso parameterkent adott tombbol es mentjuk a masodik parameterkent megadott sorba a harmadik parameterkent megadott sor index alapjan. A cv osztaly countNonZero fuggvenye visszateresi ertekkent megadja a nulla erteku elemek szamat a parameterul adott tombben. A BrainBWin.cpp fajlban a const QString BrainBWin::appName = "NEMESPOR BrainB Test"; paranccsal kezdoerteket adunk a BrainBWin osztaly appName valtozojanak ami ugye egy QString osztalybeli objektum ami konstans tipusu es mivel static is igy a memoriaba van a program futasa alatt az adott osztalyhoz tartozoan es a konstruktor nem peldanyositja objektum letrehozaskor. A QDate osztaly currentDate fuggvenyenek visszateresi erteke az aktualis datum a rendszer ideje alapjan, melyet a toString fuggvennyel sztringge konvertalunk mivel a valtozo amibe mentjuk sztring tipusu. A QDate osztaly currentMSecsSinceEpoch fuggvenyenek visszateresi erteke az 1970.01.01 00:00:00 ota eltel miliszekundumok szama, melyet a QStrin osztaly number fuggvenyevel alakitunk sztringge. A qDebug fuggveny kiirja a szabvanyos kimenetre a beleiranyitott sztringet. A QPixmap fromImage fuggvenyevel egy QImage objektumot atkonvertalunk QPixmap objektumma, mivel most kesz kepet jelenitunk meg vele, nem a pixeleket allijuk kozvetlenul. A device fuggveny visszateresi erteke az objektum amit festunk vagy 0 ha nem aktiv a paintevent, mivel jelen esetben a fuggvenyt a paintevent-ben definialtuk igy mindig aktiv lesz, akkor aktiv mikor letrejon a QPainter objektum es mig meg nem hivodik az letrejott objektumra az end fuggveny. A QPainter osztaly drawText fuggvenye az elso es masodik parameterkent adott x es y koordinatakra irja ki a hamradik parameterkent adott QString objektumot. A QPainter osztaly drawPixmap fuggvenye kirajzolja az elso es masodik parameterkent adott x es y koordinatakra a harmadik parameterkent adott QPixmap objektumot. A mouseevent-ben hasznalt pos fuggveny az eger poziciojat adja meg a kepen amire hasznaljuk az eventet, az x es y fuggvenyek pedig az x es y koordinatait a pozicionak. A key fuggveny a keyevent-ben hasznalt fuggveny melynek visszateresi erteke egesz tipusu szam ami a lenyomott billentyu azonositoja, ezeket a QT osztaly KEY strukturaja tartalmazza. A BrainThread.cpp fajlban az std::time(0) fuggveny megadja hany miliszekundum telt el a program futtatasa ota, igy minden meghivaskor mast kapunk. Az std::srand fuggveny a parameterkent megadott ertekkel inicializalja az std::rand fuggvenyt, ami a RAND_MAX generalt maximum ertek es az scrand erteke kozt general egy random szamot. Ha nulla es egy kozt generalunk random szamot hatekonyan akkor ezutan leosztjuk a kapott szamot a RAND_MAX+1.0 kifejezessel mivel a rand fuggveny altal generalt fuggveny kisebb mint a RAND_MAX igy a szam kisebb mint egy es nagyobb mint nulla mivel pozitivakat generalunk. A +1.0 azert szukseges hogy double tipusu osztassal szamoljunk, mert eredetileg egesz szamokkal szamol igy minden esetben az eredmeny nulla lenne, igy viszont egy nulla es egy kozotti lebegopontos szam. Az QThread osztalybeli msleep fuggveny altatja az aktualis QThread objektumot a parameterul adott miliszekundumig.
        </para>
        <para>
            Megoldás videó: 
        </para>
        <para>
            Megoldás forrása: <link xlink:href=""></link>               
        </para>
        <para>
            Tanulságok, tapasztalatok, magyarázat...
        </para>            
    </section>        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        
</chapter>                
